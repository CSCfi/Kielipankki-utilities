#! /usr/bin/env python3
# -*- mode: Python; -*-

from itertools import count

from vrtargslib import trans_args, trans_main
from vrtnamelib import isnames, namelist, nameindices
from vrtdatalib import asrecord

def parsearguments():
    description = '''

    Check that the sentences annotated with dependency syntax in the
    form of token id and head id (as in CoNLL formats) have the shape
    of a rooted tree: token numbers are 1, 2, 3, ..., n, one token
    depends on 0, every other token depends immediately on one of 1,
    2, ..., n, ultimately on 0. Issues in tree shapes are reported
    briefly in TSV format, with the 1-based line number (ignoring any
    empty lines) and the <sentence> tag number in the input stream.
    Success is indicated by not reporting any issue.

    '''
    parser = trans_args(description = description, inplace = False)

    parser.add_argument('--id', default = 'id',
                        help = '''

                        token id, a 1-based counter within sentence
                        (default: id)

                        ''')

    parser.add_argument('--head', default = 'head',
                        help = '''

                        dependency head, either id of another token
                        or 0 (default: head)

                        ''')

    args = parser.parse_args()
    args.prog = parser.prog
    args.inplace = None
    args.backup = None
    return args

def main(args, ins, ous):

    # TSV header
    print('Line', 'Sentence', 'Issue', sep = '\t', file = ous)

    def issome(line): return not line.isspace()

    sid, number = 0, count(start = 1)
    idix, headix = None, None
    tree = []
    for lno, line in enumerate(filter(issome, ins), start = 1):

        if isnames(line):
            idix, headix = nameindices(namelist(line),
                                       args.id,
                                       args.head)
            continue

        if line.startswith(('<sentence>',
                            '<sentence ')):
            sid = next(number)
            # at this point, either tree is empty or markup is off;
            tree.append(0)
            continue

        if line.startswith('</sentence>'):

            # fail on any head out of range (cannot test further)
            if not all(0 <= h <= n for n in [len(tree)] for h in tree):
                print(lno, sno, 'head out of range', sep = '\t', file = ous)
                tree.clear()
                continue

            # report if root not unique (but can test further)
            if tree.count(0) > 2:
                print(lno, sno, 'more than one root', sep = '\t', file = ous)

            # in a few iterations of tree[k] = tree[h], either all
            # nodes should depend on root (success), or some should
            # become otherwise stationary (failure) and of those, some
            # should be fixed points (test for such is easy to write)

            for iterations in range(10):
                for k, h in enumerate(tree): tree[k] = tree[h]
                if not any(tree): break
                if any(0 < k == h for k, h in enumerate(tree)):
                    print(lno, sno, 'cycle', sep = '\t', file = ous)
                    break
            else:
                print(lno, sno, 'failed to determine', sep = '\t', file = ous)
    
            tree.clear()
            continue

        if line.startswith('<'):
            continue

        # line is a token

        record = asrecord(line)

        (
            int(record[idix]) == len(tree) or
            print(lno, sno, 'id out of sequence', sep = '\t', file = ous)
        )

        tree.append(int(record[headix]))

if __name__ == '__main__':
    trans_main(parsearguments(), main)
