#! /usr/bin/env python3
# -*- mode: Python; -*-

from vrtargslib import trans_args, trans_main

from vrtnamelib import isnames, namelist, nameindices

from vrtdatalib import asrecord

def parsearguments():
    description = '''

    Check that the sentences annotated with dependency syntax in the
    form of token id and head id (as in CoNLL formats) have the shape
    of a rooted tree: token numbers are 1, 2, 3, ..., n, one token
    depends on 0, every other token depends immediately on one of 1,
    2, ..., n, ultimately on 0. Empty output indicates success.

    '''
    parser = trans_args(description = description)

    parser.add_argument('--id', default = 'id',
                        help = '''

                        token id, a 1-based counter within sentence
                        (default: id)

                        ''')

    parser.add_argument('--head', default = 'head',
                        help = '''

                        dependency head, either id of another token
                        or 0 (default: head)

                        ''')

    args = parser.parse_args()
    args.prog = parser.prog
    return args

def main(args, ins, ous):
    
    def issome(line): return not line.isspace()

    idix, headix = None, None
    tree = []
    for line in filter(issome, ins):

        if isnames(line):
            idix, headix = nameindices(namelist(line),
                                       args.id,
                                       args.head)
            continue

        if line.startswith(('<sentence>',
                            '<sentence ')):
            tree.append(0)
            continue

        if line.startswith('</sentence>'):

            # fail on any head out of range (cannot test further)
            if not all(0 <= h <= n for n in [len(tree)] for h in tree):
                print('head out of range', file = ous)
                tree.clear()
                continue

            # report if root not unique (but can test further)
            if tree.count(0) > 2:
                print('more than one root', file = ous)

            # in a few iterations of tree[k] = tree[h], either all
            # nodes should depend on root (success), or some should
            # become otherwise stationary (failure) and of those, some
            # should be fixed points (test for such is easy to write)

            for iterations in range(10):
                for k, h in enumerate(tree): tree[k] = tree[h]
                if not any(tree): break
                if any(0 < k == h for k, h in enumerate(tree)):
                    print('cycle', file = ous)
                    break
            else:
                print('failed to determine', file = ous)
    
            tree.clear()
            continue

        if line.startswith('<'):
            continue

        # line is a token

        record = asrecord(line)

        (
            int(record[idix]) == len(tree) or
            print('id out of sequence', file = ous)
        )

        tree.append(int(record[headix]))

if __name__ == '__main__':
    trans_main(parsearguments(), main)
