#! /usr/bin/env python3
# -*- mode: Python; -*-

from itertools import groupby, count
from subprocess import Popen, PIPE, DEVNULL
from threading import Thread
import enum, os, re, sys, tempfile, traceback

from vrtargslib import trans_args, trans_main
from vrtargslib import BadData, BadCode

from vrtnamelib import binxname, binxrest
from vrtnamelib import binnamelist, nameindex, nameindices
from vrtnamelib import bininsertnames

from vrtdatalib import binasrecord
from vrtdatalib import binunescape as unescape
from vrtdatalib import binescape as escape

# The underlying thing is known variously as "mate tools" (though mate
# tools consist of other things, too), "anna" (for whatever
# motivation, nowhere to be found), apparently "is2", and "the parser"
# and certain other locutions that describe or praise the parser.

PARSER = [ 'java', '-cp',
           '/proj/kieli/varpunen/mate-tools/anna-3-1.jar',
           'is2.parser.Parser',
           '-model', '/proj/kieli/varpunen/models/parser.model',
           '-test', '/dev/stdin'

           # extend with [ '-out', pipename ] at the point of Popen,
           # when a named-pipe name is at hand, because this version
           # of this thing writes its *diagnostics* in its stdout
]

VERSION = '0.3 (2018-10-05)'

# Let slip the first "Processing Sentence: 1 (32 ms/instance)".
# Quash the hundred thousand "2 (113 ms/instance)" that follow.
BREAKER = [ '/usr/bin/tr', '-s', r'\b', r'\n' ] # sigh
QUASHER = [ '/bin/grep', '-P', '-x', '-v', r'\d+ \(\d+ ms/instance\)' ]

def parsearguments():
    description = '''

    Pass morphologically tagged word forms in a flat vrt document
    through the parser of Mate-Tools using the model from Turku.
    Insert the syntactic dependency analysis in new fields after the
    tag field. The vrt document must have position names in a comment
    before any content. (A "flat" vrt document has no markup or
    comment lines inside sentence elements.)

'''

    parser = trans_args(version = VERSION, description = description)

    parser.add_argument('--word', '-w', metavar = 'name',
                        type = binxname, default = b'word',
                        help = 'input word-field name (default word)')
    parser.add_argument('--tag', '-t', metavar = 'name',
                        type = binxname, default = b'pos',
                        help = 'input pos-tag-field name (default pos)')
    parser.add_argument('--feat', '-f', metavar = 'name',
                        type = binxname, default = b'feat',
                        help = 'input feature-field name (default feat)')
    parser.add_argument('--prefix', '-p', metavar = 'fix',
                        type = binxname, default = b'',
                        help = 'prefix to output-field names')
    parser.add_argument('--suffix', '-s', metavar = 'fix',
                        type = binxrest, default = b'',
                        help = 'suffix to output-field names')

    group = parser.add_mutually_exclusive_group()
    group.add_argument('--quiet', '-q', action = 'store_true',
                       help = 'quash all diagnostics from the parser')
    group.add_argument('--verbose', '-v', action = 'store_true',
                       help = 'watch parser report on every sentence')

    parser.add_argument('--track', action = 'store_true',
                        help = '''

                        track execution in stderr (because termination
                        was even trickier to ensure than expected)

''')

    args = parser.parse_args()
    args.prog = parser.prog
    return args

def message(args, mess, *, track = False):
    if track:
        args.track and print(args.prog + ': --track:', mess,
                             file = sys.stderr, flush = True)
    else:
        print(args.prog + ':', mess,
              file = sys.stderr, flush = True)

def terminate(proc):
    try:
        proc.terminate()
    except ProcessLookupError:
        pass

class Kind(enum.Enum):
    # kind of line (group of them)
    meta = 1
    data = 2
    begin = 3
    names = 4
    comment = 5

def identify(line):
    # used by groupby to identify the kind of a line group
    if line.startswith(b'<!-- Positional attributes:'): return Kind.names
    if line.startswith(b'<!--'): return Kind.comment
    if line.startswith(b'<sentence'): return Kind.begin
    if line.startswith(b'<'): return Kind.meta
    return Kind.data

def main(args, inf, ouf):
    message(args, 'entered main', track = True)
    
    temp = tempfile.mkdtemp(prefix = 'vrt.')
    pipename = os.path.join(temp, 'tdpalpha')
    os.mkfifo(pipename)

    message(args, 'created named pipe: {}'.format(pipename),
            track = True)

    # attempts to open the named pipe here stalled, regardless of
    # whether it was for reading or writing

    breaker = ( None
                if args.quiet else
                Popen(BREAKER, stdin = PIPE, stdout = sys.stderr.buffer)
                if args.verbose else
                Popen(BREAKER, stdin = PIPE, stdout = PIPE) )

    quasher = ( None
                if (args.quiet or args.verbose) else
                Popen(QUASHER,
                      stdin = breaker.stdout,
                      stdout = sys.stderr.buffer) )

    # an attempt to open the named for pipe reading *here* stalled

    # somewhere here should close some standard streams to have
    # eventual broken pipes have the intended effect, right? no?
    # breaker.stdout when it is the PIPE to quasher, presumably, not
    # sure but apparently not harmful at least:

    quasher is None or breaker.stdout.close()

    with Popen(PARSER + [ '-out', pipename ],
               stdin = PIPE,
               stdout = (breaker.stdin if breaker else DEVNULL),
               stderr = sys.stderr.buffer) as parser:
        with Popen(['cat'],
                   stdin = PIPE,
                   stdout = PIPE,
                   stderr = sys.stderr.buffer) as copy:

            # is this a "useless use of cat"?

            # opening the named pipe *here* seems to succeed

            message(args, 'opening pipe for reading', track = True)
            pipe = open(pipename, mode = 'rb')
            message(args, 'opened pipe for reading', track = True)

            # combine reads pipe but on exception terminates parser
            # because merely closing pipe seemed to stall parser and
            # then stall write/flush attempts in main, requiring
            # keyboard interrupt (or other external signal) to
            # terminate the program

            t = Thread(target = combine,
                       args = (args, pipe, parser, copy, ouf))
            t.start()

            status = 1
            try:
                # raise Exception('testing termination')
                implement_main(args, inf, parser, copy)
                status = 0
            except BadData as exn:
                message(args, str(exn))
            except BrokenPipeError as exn:
                # when combine thread gets broken pipe, it closes the
                # output side of pipe and copy, then they close and
                # this thread gets broken pipe - right?
                message(args, 'broken pipe in main thread')
            except KeyboardInterrupt as exn:
                message(args, 'keyboard interrupt in main thread')
                message(args, traceback.format_exc(), track = True)
            except Exception as exn:
                message(args, traceback.format_exc())

            # these two closures may be
            # crucial for graceful
            # termination
            try:
                # so it was getting broken pipe *here* and then never
                # getting to terminate and join - did not expect this
                message(args, 'closing parser stdin in main', track = True)
                parser.stdin.close()
                message(args, 'closing copy stdin in main', track = True)
                copy.stdin.close()
            except Exception as exn:
                message(args, 'while closing in main: ' + str(exn))

            if status:
                message(args, 'non-zero status: terminating subprocesses',
                        track = True)
                terminate(parser)
                terminate(copy)
                breaker is None or terminate(breaker)
                quasher is None or terminate(quasher)

            message(args, 'joining combine thread', track = True)
            t.join()
            message(args, 'joined combine thread', track = True)

            message(args, 'removing {}'.format(pipename), track = True)
            os.remove(pipename)
            os.rmdir(temp)

            message(args, 'returning from main', track = True)

            return status

def implement_main(args, inf, parser, copy):

    # each "word" and "tag" go to parser, with empty line after
    # sentence; everything but empty goes to copy, with new "id",
    # "dephead", "deprel" (or such) in names

    wf, tf, ff = None, None, None # word, tag, feat positions
    found = False
    def isnotspace(line): return not line.isspace()
    for kind, group in groupby(filter(isnotspace, inf), identify):

        if kind is not Kind.data: found = False
        if kind is Kind.begin: found = True

        if kind is Kind.data and found:
            if wf is None:
                raise BadData('error: token before field names')
            for k, line in enumerate(group, start = 1):
                # print('DEBUG: sending token')
                # format for the whatever parser is CoNLL'09:
                # ID FORM LEMMA PLEMMA POS PPOS FEAT PFEAT
                # HEAD PHEAD DEPREL PDEPREL FILLPRED PRED APREDs
                # (er, any number of APRED1, APRED2, ...)
                # to guess where the input should be - ID, FORM,
                # POS, FEAT, right? but does the parser conform?

                record = binasrecord(line)

                # ID tab
                parser.stdin.write(str(k).encode('UTF-8'))
                parser.stdin.write(b'\t')
                # FORM tab LEMMA tab PLEMMA tab
                parser.stdin.write(unescape(record[wf]))
                parser.stdin.write(b'\t_\t_\t')
                # POS tab PPOS tab
                parser.stdin.write(unescape(record[tf]))
                parser.stdin.write(b'\t_\t')
                # FEAT tab PFEAT tab
                parser.stdin.write(unescape(record[ff]))
                parser.stdin.write(b'\t_\t')
                # HEAD tab PHEAD tab DEPREL tab PDEPREL tab
                parser.stdin.write(b'_\t_\t_\t_\t')
                # FILLPRED tab PRED nl
                parser.stdin.write(b'_\t_\n')
                copy.stdin.write(line)
            else:
                parser.stdin.write(b'\n')

                # stalled here when parser reports broken pipe but
                # then turned out to stall in writes when this was
                # commented out - but only sometimes - be a race - no
                # more closing parser output, terminating parser
                # instead

                # (flushing because these should be read in synch)

                parser.stdin.flush()
                copy.stdin.flush()
                continue

        if kind is Kind.begin:
            for line in group: copy.stdin.write(line)
            continue

        if kind is Kind.meta:
            for line in group: copy.stdin.write(line)
            continue

        if kind is Kind.data:
            for line in group: copy.stdin.write(line)
            continue

        if kind is Kind.names:
            for line in group:
                wf, tf, ff = nameindices(binnamelist(line),
                                         args.word,
                                         args.tag,
                                         args.feat)
                new = bininsertnames(line, args.tag,
                                     args.prefix + b'id' + args.suffix,
                                     args.prefix + b'head' + args.suffix,
                                     args.prefix + b'rel' + args.suffix)
                copy.stdin.write(new)
            else:
                continue

        if kind is Kind.comment:
            for line in group: copy.stdin.write(line)
            continue

        raise BadCode('this cannot happen')

def combine(args, pipe, parser, copy, out):
    '''Read whatever output (id TAB word TAB _ TAB pos ... msd TAB NL /
    NL) and flat vrt from the copy process. Insert dependency analysis
    from parser to the vrt at the named position.

    This is run as a thread that consumes the two processes.

    '''

    message(args, 'enter combine', track = True)

    try:
        implement_combine(args, pipe, copy, out)
    except BrokenPipeError:
        message(args, 'broken pipe in combine thread')
    except StopIteration:
        # from next(response) when main thread got keyboard interruption
        message(args, 'stop iteration in combine thread')
    except ValueError as exn:
        # sometimes keyboard interruption in main thread produces here
        # a readline of closed file
        message(args, 'value error in combine thread:' + str(exn))
    except Exception as exn:
        message(args, traceback.format_exc())
    finally:
        # closing their stdouts should send parser (behind pipe) and
        # copy the signal to shut down, right? and then the main
        # thread should get broken pipe to indicate that it can no
        # longer write to them? but parser does not seem to propagate
        # the signal when it gets the signal and things stall
        try:
            message(args, 'terminating parser in combine', track = True)
            terminate(parser)
            # seems that parser does not terminate when it gets broken
            # pipe nor does it propagate the broken pipe to main that
            # then stalls writing to the parser - it just reports the
            # exception to stderr and stalls? - so this should
            # terminate parser instead: combine does need access!
        except Exception as exn:
            message(args, 'terminating parser in combine: ' + str(exn))
        try:
            message(args, 'terminating copy in combine', track = True)
            terminate(copy) # .stdout.close() # no need to wait?
        except Exception as exn:
            message(args, 'terminating copy in combine: ' + str(exn))

        finally:
            message(args, 'returning from combine', track = True)

def implement_combine(args, pipe, copy, out):

    response = (tokens
                for isempty, tokens
                in groupby(pipe, bytes.isspace)
                if not isempty)

    mf = None # msd field index, after which insert new
    found = False
    for kind, group in groupby(copy.stdout, identify):

        if kind is not Kind.data: found = False
        if kind is Kind.begin: found = True

        if (kind is Kind.data) and found:
            for new, old in zip(next(response), group):
                [
                    ID, form, lemma, plemma,
                    pos, ppos, feat, pfeat,
                    dephead, pdephead, deprel, pdeprel,
                    fillpred, pred
                ] = binasrecord(new)
                values = binasrecord(old)
                values.insert(mf + 1, escape(pdeprel))
                values.insert(mf + 1, escape(pdephead))
                values.insert(mf + 1, escape(ID))
                out.write(b'\t'.join(values))
                out.write(b'\n')
            else:
                continue

        if kind is Kind.names:
            for line in group:
                mf = nameindex(binnamelist(line), args.tag)
                out.write(line)
            else:
                continue

        for line in group:
            # print('DEBUG: catchall write')
            out.write(line)
        else:
            continue

if __name__ == '__main__':
    trans_main(parsearguments(), main,
               in_as_text = False,
               out_as_text = False)
