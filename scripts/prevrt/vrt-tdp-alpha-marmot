#! /usr/bin/env python3
# -*- mode: Python; -*-

from itertools import groupby, count
from subprocess import Popen, PIPE
from threading import Thread
import enum, os, re, sys, traceback

from vrtargslib import trans_args, trans_main
from vrtargslib import BadData, BadCode

VERSION = '0.2 (2018-09-27)'

MARMOT = [
    'java',
    '-cp', '/proj/kieli/varpunen/marmot-2014-10-22.jar',
    'marmot.morph.cmd.Annotator',
    '--model-file', '/proj/kieli/varpunen/models/fin_model.marmot',
    '--test-file', 'form-index=0,token-feature-index=1,/dev/stdin',
    '--pred-file', '/dev/stdout'
]

# TODO should make checks - cannot have spaces or < & > + and so.
# TODO should have these types in vrtargslib
# TODO maybe these should not encode?
def nametype(name): return name.encode('UTF-8')
def suffixtype(fix): return fix.encode('UTF-8')

def parsearguments():
    description = '''

    Pass word forms and specially prepared features in a flat vrt
    document through MarMoT tagger using the model from the alpha
    version of the Turku dependency parser. Insert the new tags and
    features in new fields after the input feature field. The vrt
    document must have position names before any content. (A "flat"
    vrt document has no markup or comment lines inside sentence
    elements.)

'''
    parser = trans_args(version = VERSION, description = description)
    parser.add_argument('--word', '-w', metavar = 'name',
                        type = nametype, default = b'word',
                        help = 'input word field name (default word)')
    parser.add_argument('--tag', '-t', metavar = 'name',
                        type = nametype, default = b'marmot.in',
                        help = 'input tag field name (default marmot.in)')
    parser.add_argument('--prefix', '-p', metavar = 'fix',
                        type = nametype, default = b'',
                        help = 'prefix to output field names')
    parser.add_argument('--suffix', '-s', metavar = 'fix',
                        type = suffixtype, default = b'',
                        help = 'suffix to output field names')

    args = parser.parse_args()
    args.prog = parser.prog
    return args

def message(args, mess):
    print(args.prog + ':', mess, file = sys.stderr)

def terminate(proc):
    try:
        proc.terminate()
    except ProcessLookupError:
        pass

def main(args, inf, ouf):
    with Popen(MARMOT,
               stdin = PIPE,
               stdout = PIPE,
               stderr = sys.stderr.buffer) as marmot:
        with Popen(['cat'],
                   stdin = PIPE,
                   stdout = PIPE,
                   stderr = sys.stderr) as copy:

            # is this a "useless use of cat"?

            t = Thread(target = combine, args = (args, marmot, copy, ouf))
            t.start()

            status = 1
            try:
                implement_main(args, inf, marmot, copy)
                status = 0
            except BadData as exn:
                message(args, exn)
            except BrokenPipeError as exn:
                message(args, 'broken pipe in main thread')
            except KeyboardInterrupt as exn:
                message(args, 'keyboard interrupt in main thread')
            except Exception as exn:
                print(traceback.format_exc(), file = sys.stderr)

            if status:
                terminate(marmot)
                terminate(copy)
            else:
                marmot.stdin.close()
                copy.stdin.close()

            try:
                t.join()
            except KeyboardInterrupt:
                message(args, 'keyboard interrupt in main thread')
                status = 1

            return status

def implement_main(args, inf, marmot, copy):

    # each "word" and "tag" go to marmot, with empty line after
    # sentence; everything but empty goes to copy, with new
    # "marmot.pos", "marmot.feat" (or such) in names

    wf, pf = None, None
    found = False
    def isnotspace(line): return not line.isspace()
    for kind, group in groupby(filter(isnotspace, inf), identify):

        if kind is not Kind.data: found = False
        if kind is Kind.begin: found = True

        if kind is Kind.data and found:
            if wf is None:
                raise BadData('error: token before field names')
            for k, line in enumerate(group, start = 1):
                
                marmot.stdin.write(unescape(getword(line, wf))) # rename getword
                marmot.stdin.write(b'\t')
                poses = unescape(getword(line, pf))
                marmot.stdin.write(poses)
                marmot.stdin.write(b'\n')
                copy.stdin.write(line)
            else:
                marmot.stdin.write(b'\n')
                marmot.stdin.flush()
                copy.stdin.flush()
                continue

        if kind is Kind.begin:
            for line in group: copy.stdin.write(line)
            continue

        if kind is Kind.meta:
            for line in group: copy.stdin.write(line)
            continue

        if kind is Kind.data:
            for line in group: copy.stdin.write(line)
            continue

        if kind is Kind.names:
            for line in group:
                wf = getpos(line, args.word)
                pf = getpos(line, args.tag)
                posname = args.prefix + b'marmot.pos' + args.suffix
                featname = args.prefix + b'marmot.feat' + args.suffix
                copy.stdin.write(addnames(line, args.tag, posname, featname))
            else:
                continue

        if kind is Kind.comment:
            for line in group: copy.stdin.write(line)
            continue

        raise BadCode('this cannot happen')

# old values are passed unescaped to the underlying process,
# new values are inserted escaped to the output stream
bare, code = (b'&', b'<', b'>'), (b'&amp;', b'&lt;', b'&gt;')
def encm(m, d = dict(zip(bare, code))): return d[m.group()]
def decm(m, d = dict(zip(code, bare))): return d[m.group()]
def escape(value): return re.sub(b'[&<>]', encm, value)
def unescape(value): return re.sub(b'&(amp|lt|gt);', decm, value)

class Kind(enum.Enum):
    # kind of line (group of them)
    meta = 1
    data = 2
    begin = 3
    names = 4
    comment = 5

def identify(line):
    # used by groupby to identify the kind of a line group
    if line.startswith(b'<!-- Positional attributes:'): return Kind.names
    if line.startswith(b'<!--'): return Kind.comment
    if line.startswith(b'<sentence'): return Kind.begin
    if line.startswith(b'<'): return Kind.meta
    return Kind.data

def combine(args, marmot, copy, out):
    '''Read marmot output (id TAB word TAB _ TAB pos ... msd TAB NL / NL)
    and flat vrt from the copy process. Insert tags from marmot to the
    vrt at the named position.

    This is run as a thread that consumes the two processes.

    '''

    fail = True
    try:
        implement_combine(args, marmot, copy, out)
        fail = False
    except BrokenPipeError:
        message(args, 'broken pipe in combine thread')
    except StopIteration:
        # from next(response) when main thread got keyboard interruption
        message(args, 'stop iteration in combine thread')
    except ValueError as exn:
        # sometimes keyboard interruption in main thread produces here
        # a readline of closed file (or at least it did in one stage
        # in development)
        message(args, 'value error in combine thread ' + str(exn))
    finally:
        if fail:
            terminate(marmot)
            terminate(copy)

def implement_combine(args, marmot, copy, out):
    '''Thread may find pipe closed.'''

    response = (tokens
                for isempty, tokens
                in groupby(marmot.stdout, bytes.isspace)
                if not isempty)
    
    mf = None # marmot.in field index, after which insert new
    found = False
    for kind, group in groupby(copy.stdout, identify):

        if kind is not Kind.data: found = False
        if kind is Kind.begin: found = True

        if (kind is Kind.data) and found:
            for new, old in zip(next(response), group):
                [
                    # http://ufal.mff.cuni.cz/
                    # conll2009-st/task-description.html
                    # ID FORM LEMMA PLEMMA POS PPOS FEAT PFEAT
                    # HEAD PHEAD DEPREL PDEPREL FILLPRED PRED APREDs
                    # but MarMoT truncates at eight fields
                    # https://github.com/muelletm/cistern/blob/wiki/marmot.md
                    # (actual produced ID is 1-based as it should)
                    ID, form, lemma, plemma,
                    pos, ppos, feat, pfeat
                ] = new.rstrip(b'\n').split(b'\t')
                values = old.rstrip(b'\n').split(b'\t')
                values.insert(mf + 1, escape(pfeat))
                values.insert(mf + 1, escape(ppos))
                out.write(b'\t'.join(values))
                out.write(b'\n')
            else:
                continue

        if kind is Kind.names:
            for line in group:
                mf = getpos(line, args.tag)
                out.write(line)
            else:
                continue

        for line in group:
            out.write(line)
        else:
            continue

def getpos(names, name):
    namelist = re.findall(br'[\w.+]+', names)[2:]
    try:
        return namelist.index(name)
    except ValueError:
        raise BadData('no such name: {}'.format(name.decode('UTF-8')))

def addnames(names, atname, *afternames):
    '''Build new name-line with afternames inserted after atname.'''
    new = re.findall(br'[\w.+]+', names)[2:]
    if atname not in new:
        raise BadData('no such positional attribute: {}'
                      .format(atname.decode('UTF-8')))
    for aftername in reversed(afternames):
        if aftername in new:
            raise BadData('positional attribute already in use: {}'
                          .format(aftername.decode('UTF-8')))
        else:
            new.insert(new.index(atname) + 1, aftername)
    return b' '.join([b'<!-- Positional attributes:'] + new + [b'-->\n'])

def getword(line, pos): # needs to be renamed
    return line.rstrip(b'\n').split(b'\t')[pos]


if __name__ == '__main__':
    trans_main(parsearguments(), main,
               in_as_text = False,
               out_as_text = False)
