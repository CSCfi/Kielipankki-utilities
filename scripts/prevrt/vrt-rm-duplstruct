#! /usr/bin/env python3
# -*- mode: Python; -*-


"""
vrt-rm-duplstruct

Output the VRT input with structures (elements) with equal content
removed.
"""


import hashlib
import re
import sys

from enum import Enum
from itertools import groupby

from scriptutil import InputProcessor


class DuplicateStructureRemover(InputProcessor):

    """Remove VRT structures with duplicated content."""

    VERSION = '0.1 (2018-09-06)'
    DESCRIPTION = """
    Output the input VRT with structures with duplicated content removed.
    """
    ARGSPECS = [
        ('--structure-name = STRUCT -> struct_name',
         'check structures STRUCT for duplicate content',
         dict(default='text')),
        ('--within-structure = STRUCT -> within_struct',
         'remove duplicates separately within each structure STRUCT, not'
         ' across them (default: remove duplicates within the whole input)'),
        ('--comments',
         'add an XML comment for each omitted duplicate'),
        ('--verbose',
         'write log output to stderr'),
    ]

    def __init__(self):
        super().__init__()

    def implement_main(self, inf, ouf):

        class LineType(Enum):
            struct_begin = 1
            struct_end = 2
            within_begin = 3
            within_end = 4
            other = 5

        def make_begins_end(struct_name):
            if struct_name is None:
                return [], None
            else:
                return ([b'<' + struct_name.encode() + ch
                         for ch in [b' ', b'>']],
                        b'</' + struct_name.encode() + b'>\n')

        LESS_THAN = b'<'[0]
        linenum = 1
        content = None
        structs_info = {}
        struct_name = self._args.struct_name
        struct_begins, struct_end = make_begins_end(struct_name)
        within_struct = self._args.within_struct
        within_begins, within_end = make_begins_end(within_struct)
        in_struct = False
        # in_within is always True if no --within-structure was
        # specified
        in_within = (within_struct is None)
        struct_num = 0
        struct_begin_line = ''
        comments = self._args.comments
        verbose = self._args.verbose

        def is_struct_begin(line):
            return 

        def identify_line(line):
            if line[0] == LESS_THAN:
                if in_within:
                    if line == struct_end:
                        return LineType.struct_end
                    elif line == within_end:
                        return LineType.within_end
                    elif any(line.startswith(begin) for begin in struct_begins):
                        return LineType.struct_begin
                elif any(line.startswith(begin) for begin in within_begins):
                    return LineType.within_begin
            return LineType.other

        def log_duplicate(text):
            if comments:
                ouf.write(b'<!-- ' + text.encode() + b' -->\n')
            if verbose:
                sys.stderr.write(self.argparser.prog + ': ' + text + '\n')

        def extract_attrs(struct_line):
            # print(struct_line)
            attr_end = struct_line.find(b'>')
            attr_begin = (struct_line.find(b' ') + 1) or attr_end
            return struct_line[attr_begin:attr_end].decode()

        def check_if_duplicate(lines):
            nonlocal linenum
            linecount = len(lines)
            lines = b''.join(lines)
            hash = hashlib.md5(lines).digest()
            this_attrs = extract_attrs(struct_begin_line)
            this_begin = linenum - 1
            this_end = linenum + linecount
            if hash in structs_info:
                other_attrs, other_begin, other_end = structs_info[hash]
                log_duplicate(
                    'DUPLICATE: Omitted structure "{name}" on lines'
                    ' {this_begin}...{this_end} (attributes: {this_attrs})'
                    ' with content equal to "{name}" on lines '
                    ' {other_begin}...{other_end} (attributes: {other_attrs}).'
                    .format(name=struct_name, **locals()))
            else:
                structs_info[hash] = (
                    this_attrs,
                    this_begin,
                    this_end,
                )
                ouf.write(struct_begin_line)
                ouf.write(lines)
                ouf.write(struct_end)
            linenum += linecount

        def output_lines(lines):
            nonlocal linenum
            for line in lines:
                ouf.write(line)
                linenum += 1

        for linetype, group in groupby(inf, identify_line):
            if in_within:
                if linetype == LineType.struct_begin:
                    struct_begin_line = next(group)
                    in_struct = True
                    struct_num += 1
                    linenum += 1
                elif linetype == LineType.struct_end:
                    check_if_duplicate(content)
                    in_struct = False
                    linenum += 1
                elif linetype == LineType.within_end:
                    output_lines(group)
                    in_within = False
                    structs_info = {}
                elif in_struct:
                    content = list(group)
                else:
                    output_lines(group)
            else:
                if linetype == LineType.within_begin:
                    in_within = True
                output_lines(group)


if __name__ == '__main__':
    DuplicateStructureRemover().run()
