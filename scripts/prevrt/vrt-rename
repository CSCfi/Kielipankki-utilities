#! /usr/bin/env python3
# -*- mode: Python; -*-

from argparse import ArgumentParser, ArgumentTypeError
from itertools import groupby, chain
from tempfile import mkstemp
import enum, os, re, sys, traceback

VERSION = '0.1 (2018-06-08)'

import signal
signal.signal(signal.SIGINT, signal.SIG_DFL)
signal.signal(signal.SIGPIPE, signal.SIG_DFL)

class BadData(Exception): pass # stack trace is just noise
class BadCode(Exception): pass # this cannot happen

def spectype(text):
    if re.fullmatch(R'[\w.]+=[\w.]+', text):
        return text.encode('UTF-8').split(b'=')
    raise ArgumentTypeError('malformed specification: {}'
                            .format(text))

parser = ArgumentParser(description = '''

Rename some positional attributes.

''')

parser.add_argument('infile', nargs = '?', metavar = 'file',
                    help = 'input file (default stdin)')
parser.add_argument('--out', '-o',
                    dest = 'outfile', metavar = 'file',
                    help = 'output file (default stdout)')
parser.add_argument('--in-place', '-i',
                    dest = 'inplace', action = 'store_true',
                    help = 'overwrite input file with output')
parser.add_argument('--backup', '-b', metavar = 'bak',
                    help = 'keep input file with suffix bak')
parser.add_argument('--map', '-m', metavar = 'old=new',
                    dest = 'mapping', action = 'append',
                   type = spectype, default = [],
                    help = 'map old name to new name')
parser.add_argument('--version', action = 'store_true',
                    help = 'print {} and exit'.format(VERSION))

class Kind(enum.Enum):
    # kind of line (group of them)
    meta = 1
    data = 2
    begin = 3
    names = 4
    comment = 5

def identify(line):
    # used by groupby to identify the kind of a line group
    if line.startswith(b'<!-- Positional attributes:'): return Kind.names
    if line.startswith(b'<!--'): return Kind.comment
    if line.startswith(b'<sentence'): return Kind.begin
    if line.startswith(b'<'): return Kind.meta
    return Kind.data

def makenew(old):
    names = re.findall(br'[\w.+]+', old)[2:]
    rep = dict(args.mapping)
    for name in rep:
        if name not in names:
            raise BadData('error: not an old name: ' + name.decode('UTF-8'))
    
    new = [ rep.get(name, name) for name in names ]

    if len(set(new)) < len(new):
        raise BadData('error: duplicate names')

    return b' '.join(chain([b'<!-- Positional attributes:'],
                           new, [b'-->\n']))

def wrap_main():

    if (args.backup is not None) and '/' in args.backup:
        print('usage: --backup suffix cannot contain /', file = sys.stderr)
        exit(1)

    if (args.backup is not None) and not args.backup:
        print('usage: --backup suffix cannot be empty', file = sys.stderr)
        exit(1)

    if (args.backup is not None) and not args.inplace:
        print('usage: --backup requires --in-place', file = sys.stderr)
        exit(1)

    if args.inplace and (args.infile is None):
        print('usage: --in-place requires input file', file = sys.stderr)
        exit(1)

    if args.inplace and (args.outfile is not None):
        print('usage: --in-place not allowed with --out', file = sys.stderr)
        exit(1)

    if (args.outfile is not None) and os.path.exists(args.outfile):
        # easier to check this than that output file is different than
        # input file, though it be annoying when overwrite is wanted
        print('usage: --out file must not exist', file = sys.stderr)
        exit(1)

    try:
        if args.inplace or (args.outfile is not None):
            head, tail = os.path.split(args.infile
                                       if args.inplace
                                       else args.outfile)
            fd, temp = mkstemp(dir = head, prefix = tail)
            os.close(fd)
        else:
            temp = None

        with ((args.infile and open(args.infile, mode = 'br'))
              or sys.stdin.buffer) as inf:
            with ((temp and open(temp, mode = 'bw'))
                  or sys.stdout.buffer) as ouf:
                status = main(inf, ouf)

        args.backup and os.rename(args.infile, args.infile + args.backup)
        args.inplace and os.rename(temp, args.infile)
        args.outfile and os.rename(temp, args.outfile)
        exit(status)
    except IOError as exn:
        print(exn, file = sys.stderr)
        exit(1)

def main(inf, ouf):
    status = 1
    try:
        implement_main(inf, ouf)
        status = 0
    except BadData as exn:
        print(parser.prog + ':', exn, file = sys.stderr)
    except Exception as exn:
        print(traceback.format_exc(), file = sys.stderr)

    return status

def implement_main(inf, ouf):

    seen = False
    def isnotspace(line): return not line.isspace()
    for kind, group in groupby(filter(isnotspace, inf), identify):

        if kind is Kind.data:
            for line in group: ouf.write(line)
            continue

        if kind is Kind.begin:
            if not seen:
                raise BadData('error: no names before sentence')
            for line in group: ouf.write(line)
            continue

        if kind is Kind.meta:
            for line in group: ouf.write(line)
            continue

        if kind is Kind.data:
            for line in group: ouf.write(line)
            continue

        if kind is Kind.names:
            seen = True
            for line in group: ouf.write(makenew(line))
            continue

        if kind is Kind.comment:
            for line in group: ouf.write(line)
            continue

        raise BadCode('this cannot happen')

if __name__ == '__main__':
    args = parser.parse_args()
    if args.version:
        print(VERSION)
    else:
        wrap_main()
