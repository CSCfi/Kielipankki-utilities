#! /usr/bin/env python3
# -*- mode: Python; -*-

from argparse import ArgumentParser, ArgumentTypeError
from itertools import groupby, chain
from tempfile import mkstemp
import enum, os, re, sys, traceback

VERSION = '0.1 (2018-06-07)'

import signal
signal.signal(signal.SIGINT, signal.SIG_DFL)
signal.signal(signal.SIGPIPE, signal.SIG_DFL)

class BadData(Exception): pass # stack trace is just noise
class BadCode(Exception): pass # this cannot happen

def spectype(text):
    # TODO: name spec is too permissive
    # TODO: should reject digit in front
    if re.fullmatch(R'[1-9][0-9]*=\w+', text):
        return text.encode('UTF-8')
    raise ArgumentTypeError('malformed specification: {}'
                            .format(text))

def numtype(text):
    if re.fullmatch(R'[1-9][0-9]*', text):
        return int(text)
    raise ArgumentTypeError('malformed number of fields: {}'
                            .format(text))

parser = ArgumentParser(description = '''

Insert a positional-attributes comment at the beginning of a vrt
document to give names for the fields. Also replace any existing
positional-attributes comment. Fail if the number of fields does not
match the new names. (Default names are V1, V2, ...)

''')

parser.add_argument('infile', nargs = '?', metavar = 'file',
                    help = 'input file (default stdin)')
parser.add_argument('--out', '-o',
                    dest = 'outfile', metavar = 'file',
                    help = 'output file (default stdout)')
parser.add_argument('--in-place', '-i',
                    dest = 'inplace', action = 'store_true',
                    help = 'overwrite input file with output')
parser.add_argument('--backup', '-b', metavar = 'bak',
                    help = 'keep input file with suffix bak')
parser.add_argument('--number', '-n', metavar = 'num',
                    type = numtype, default = 1,
                    help = 'number of fields')
parser.add_argument('--position', '-k', metavar = 'k=name',
                    action = 'append',
                   type = spectype, default = [],
                    help = 'name for position k, 1-based')
parser.add_argument('--version', action = 'store_true',
                    help = 'print {} and exit'.format(VERSION))

class Kind(enum.Enum):
    # kind of line (group of them)
    meta = 1
    data = 2
    begin = 3
    names = 4
    comment = 5

def identify(line):
    # used by groupby to identify the kind of a line group
    if line.startswith(b'<!-- Positional attributes:'): return Kind.names
    if line.startswith(b'<!--'): return Kind.comment
    if line.startswith(b'<sentence'): return Kind.begin
    if line.startswith(b'<'): return Kind.meta
    return Kind.data

def makenames():
    positions = dict((int(k), name)
                     for spec in args.position
                     for k, name in [ spec.split(b'=') ])
    number = max(args.number, max(positions, default = 1))
    base = [ b'V' + str(k).encode('UTF-8') for k in range(1, number + 1) ]
    for k, name in positions.items(): base[k - 1] = name

    if len(set(base)) < len(base):
        raise BadData('error: duplicate names')

    line = b' '.join(chain([b'<!-- Positional attributes:'],
                           base, [b'-->\n']))
    return line, len(base)

def wrap_main():

    if (args.backup is not None) and '/' in args.backup:
        print('usage: --backup suffix cannot contain /', file = sys.stderr)
        exit(1)

    if (args.backup is not None) and not args.backup:
        print('usage: --backup suffix cannot be empty', file = sys.stderr)
        exit(1)

    if (args.backup is not None) and not args.inplace:
        print('usage: --backup requires --in-place', file = sys.stderr)
        exit(1)

    if args.inplace and (args.infile is None):
        print('usage: --in-place requires input file', file = sys.stderr)
        exit(1)

    if args.inplace and (args.outfile is not None):
        print('usage: --in-place not allowed with --out', file = sys.stderr)
        exit(1)

    if (args.outfile is not None) and os.path.exists(args.outfile):
        # easier to check this than that output file is different than
        # input file, though it be annoying when overwrite is wanted
        print('usage: --out file must not exist', file = sys.stderr)
        exit(1)

    try:
        newnames, n = makenames()
    except BadData as exn:
        print(exn, file = sys.stderr)
        exit(1)
    
    try:
        if args.inplace or (args.outfile is not None):
            head, tail = os.path.split(args.infile
                                       if args.inplace
                                       else args.outfile)
            fd, temp = mkstemp(dir = head, prefix = tail)
            os.close(fd)
        else:
            temp = None

        with ((args.infile and open(args.infile, mode = 'br'))
              or sys.stdin.buffer) as inf:
            with ((temp and open(temp, mode = 'bw'))
                  or sys.stdout.buffer) as ouf:
                status = main(inf, ouf, newnames, n)

        args.backup and os.rename(args.infile, args.infile + args.backup)
        args.inplace and os.rename(temp, args.infile)
        args.outfile and os.rename(temp, args.outfile)
        exit(status)
    except IOError as exn:
        print(exn, file = sys.stderr)
        exit(1)

def main(inf, ouf, newnames, n):
    status = 1
    try:
        implement_main(inf, ouf, newnames, n)
        status = 0
    except BadData as exn:
        print(exn, file = sys.stderr)
    except Exception as exn:
        print(traceback.format_exc(), file = sys.stderr)

    return status

def implement_main(inf, ouf, newnames, n):

    ouf.write(newnames)

    first = True
    found = False
    def isnotspace(line): return not line.isspace()
    for kind, group in groupby(filter(isnotspace, inf), identify):

        if kind is not Kind.data: found = False
        if kind is Kind.begin: found = True

        if kind is Kind.data and found:
            if first:
                first, line = False, next(group)
                if len(line.split(b'\t')) == n:
                    ouf.write(line)
                else:
                    raise BadData('error: unexpected number of fields')
            for line in group: ouf.write(line)
            continue

        if kind is Kind.begin:
            for line in group: ouf.write(line)
            continue

        if kind is Kind.meta:
            for line in group: ouf.write(line)
            continue

        if kind is Kind.data:
            for line in group: ouf.write(line)
            continue

        if kind is Kind.names:
            line = next(group)
            if len(re.findall(br'[\w+]+', line)) == n + 2:
                ouf.write(newnames)
            else:
                raise BadData('error: unexpected number of names')
            for line in group: ouf.write(newnames)
            continue

        if kind is Kind.comment:
            for line in group: ouf.write(line)
            continue

        raise BadCode('this cannot happen')

if __name__ == '__main__':
    args = parser.parse_args()
    if args.version: print(VERSION) ; exit(0)
    wrap_main()
