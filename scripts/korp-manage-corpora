#! /bin/sh
# -*- coding: utf-8 -*-

# Copy or rename a Korp corpus to another name or remove a Korp
# corpus: CWB data directory, registry file, data in the Korp MySQL
# database
#
# korp-manage-corpora --help for more information
#
# TODO:
# - Handle alignment attributes.
# - Add command "alias": symlink CWB data, copy registry and MySQL
#   data.


progname=`basename $0`
progdir=`dirname $0`

baksuff_default="-YYYYMMDDhhmmss"
verbose=1


usage_header="Usage: $progname [options] (copy | rename) source target
       $progname [options] --pattern=src:trg (copy | rename) source ...
       $progname [options] remove corpus ...

Manage (copy, rename or remove) the Korp corpora with the specified
corpus ids: CWB data directory, registry file and Korp MySQL data
(time data, lemgram index, relations tables and authorization data).

The commands copy, rename and remove can be abbreviated as cp, mv and
rm, respectively."

optspecs='
pattern|substitution-pattern=PATT substpatt
    Use the substitution pattern PATT to form the new names for the
    corpora in copy or rename. PATT can be a Perl substitution
    expression "s/SOURCE/TARGET/" or semicolon-separated list of them,
    or it can be of the form SOURCE:TARGET, which is converted to the
    Perl expression "s/SOURCE/TARGET/". Note that the "e" flag is not
    allowed in the substitution expression, for security reasons.
force
    Force overwriting the target of a copy or rename if it exists. The
    existing target is backed up by default; use --backup-suffix="" to
    omit backups.
backup-suffix|suffix=SUFFIX "'$baksuff_default'" baksuff
    Use SUFFIX as the suffix for the backup corpus name; use "" to
    make no backups.
dry-run
    Output information on what would be done but do not actually do
    it. (Cancels the effect of a possible --quiet.)
verbose { verbose=2 }
    Output more detailed information on what is done (or would be
    done).
quiet { verbose= }
    Suppress informational messages.
corpus-root=DIR "$corpus_root" { set_corpus_root "$1" }
    Use DIR as the root directory of corpus files.
registry=DIR "$cwb_regdir" { set_corpus_registry "$1" }
    Use DIR as the CWB registry directory.
'

. $progdir/korp-lib.sh

# Process options
eval "$optinfo_opt_handler"


case "$1" in
    "copy" | "cp" )
	command="copy"
	cmd_verb="Copying"
	;;
    "rename" | "mv" )
	command="rename"
	cmd_verb="Renaming"
	;;
    "remove" | "rm" )
	command="remove"
	cmd_verb="Removing"
	;;
    "" )
	error "Please specify command and corpus or corpora"
	;;
    * )
	error "Unrecognized command \"$1\""
	;;
esac
if [ "$command" = "remove" ] || [ "x$substpatt" != x ]; then
    if [ "x$2" = x ]; then
	error "Please specify at least one corpus id"
    fi
else
    if [ "x$3" = x ]; then
	error "Please specify source and target corpus id"
    fi
fi
shift

check_perl_syntax () {
    local perl_msg
    perl_msg=$(perl -c -e "$1" 2>&1)
    if [ $? != 0 ]; then
	perl_msg=${perl_msg% at -e *}
	error "Perl syntax error in substitution \"$1\": $perl_msg"
    fi
}

if [ "x$substpatt" != x ]; then
    if [ "$command" = "remove" ]; then
	error "Cannot use --pattern with command remove"
    elif in_str ":" "$substpatt" && ! str_hasprefix "$substpatt" "s/"; then
	source=${substpatt%%:*}
	target=${substpatt#*:}
	substpatt="s/$source/$target/"
    else
	for patt in $(echo "$substpatt" | tr ";" " "); do
	    if [ "${patt#s/}" = "$patt" ]; then
		# Require that the Perl expression is s/.../.../, so
		# that it cannot be e.g. unlink (remove)
		error "Substitution expression is not of the form \"SOURCE:TARGET\" or \"s/SOURCE/TARGET/\": $patt"
	    else
		flags=${patt##*/}
		if in_str "e" "$flags"; then
		    # Forbid the "e" (eval) flag, as it could be used for
		    # e.g. unlink
		    error "Substitution expression may not contain the flag \"e\": $patt"
		fi
	    fi
	    check_perl_syntax "$patt"
	done
    fi
    check_perl_syntax "$substpatt"
fi

if [ "$baksuff" = "$baksuff_default" ]; then
    baksuff=-$(date '+%Y%m%d%H%M%S')
fi

if [ "$command" = "remove" ] || [ "x$substpatt" != x ]; then
    corpora=$(list_corpora "$@")
elif [ "x$3" != x ]; then
    shift 2
    error "Spurious argument(s) after source and target: $@"
else
    corpora=$1
    target_corpus=$2
fi

if [ "x$verbose" = x ] && [ "x$dry_run" != x ]; then
    warn "--dry-run cancels the effect of --quiet"
    verbose=1
fi


multicorpus_tables="timedata timedata_date timespans lemgram_index corpus_info"
multicorpus_tables_auth="auth_license auth_lbr_map auth_allow"


# If --verbose, echo the first argument (preceded by two spaces). If
# not --dry-run, execute the rest of the arguments as a command.
run_verb () {
    local msg
    msg=$1
    shift
    if [ "x$dry_run" != x ]; then
	msg="Dry run: $msg"
    fi
    echo_verb 2 "  $msg"
    if [ "x$dry_run" = x ]; then
	"$@"
    fi
}

extract_datadir () {
    local regfile
    regfile=$1
    grep '^HOME ' $regfile |
    cut -d' ' -f2
}

manage_data () {
    local cmd source target source_datadir top_datadir target_datadir
    cmd=$1
    source=$2
    target=$3
    source_datadir=$(extract_datadir $cwb_regdir/$source)
    top_datadir=$(echo "$source_datadir" | sed -e 's,\(.*\)/.*,\1,')
    if [ "$cmd" = "remove" ]; then
	run_verb "Removing data directory $source_datadir and its contents" \
		 rm_datadir "$source_datadir"
    else
	target_datadir=$top_datadir/$target
	if [ "$cmd" = "copy" ]; then
	    run_verb "Copying data directory $source_datadir to $target_datadir" \
		     cp_datadir "$source_datadir" "$target_datadir"
	else
	    run_verb "Renaming data directory $source_datadir to $target_datadir" \
		     mv_datadir "$source_datadir" "$target_datadir"
	fi
    fi
}

rm_datadir () {
    rm -rf "$1"
}

cp_datadir () {
    cp -dpr "$1" "$2"
    ensure_perms "$2"
}

mv_datadir () {
    mv "$1" "$2"
    ensure_perms "$1"
}

manage_registry () {
    local cmd source target source_u target_u source_reg target_reg
    cmd=$1
    source=$2
    source_u=$(toupper $source)
    source_reg=$cwb_regdir/$source
    if [ "$cmd" != "remove" ]; then
	target=$3
	target_u=$(toupper $target)
	target_reg=$cwb_regdir/$target
	run_verb "Copying registry file $source_reg to $target_reg, changing corpus id" \
		 cp_regfile $source $target $source_u $target_u \
		 "$source_reg" "$target_reg"
    fi
    if [ "$cmd" != "copy" ]; then
	run_verb "Removing registry file $source_reg" \
		 rm_regfile "$source_reg"
    fi
}

cp_regfile () {
    local source target source_u target_u source_reg target_reg
    source=$1
    target=$2
    source_u=$3
    target_u=$4
    source_reg=$5
    target_reg=$6
    cat "$source_reg" |
	sed -e '
		s,^\(## registry entry for corpus \)'$source_u',\1'$target_u',;
		s,^\(ID *\)'$source',\1'$target',;
		s,^\(HOME .*/\)'$source',\1'$target',;
		s,^\(INFO .*/\)'$source'\(/\.info\),\1'$target'\2,' \
		    > "$target_reg"
    ensure_perms "$target_reg"
}

rm_regfile () {
    rm "$1"
}

mysql_make_manage_table_rows () {
    local cmd source_u target_u cols cols_list table sql_stmt
    cmd=$1
    source_u=$2
    target_u=$3
    shift 3
    for table in "$@"; do
	if [ "$cmd" = "remove" ]; then
	    echo "DELETE FROM \`$table\` WHERE corpus='$source_u';"
	elif [ "$cmd" = "rename" ]; then
	    # This assumes that corresponding rows with corpus =
	    # $target_u do not exist: they would cause an error.
	    echo "UPDATE \`$table\` SET corpus='$target_u' WHERE corpus='$source_u';"
	elif [ "$cmd" = "copy" ]; then
	    cols=$(mysql_list_table_cols $table)
	    if [ "x$cols" != x ]; then
		cols_list=$(
		    echo $cols |
		    sed -e 's/\([^ ][^ ]*\)/`\1`/g; s/ /, /g;
			    s/`corpus`/'"'$target_u'/"
		)
		if [ "x$force" != x ]; then
		    sql_stmt="REPLACE"
		else
		    sql_stmt="INSERT IGNORE"
		fi
		echo "$sql_stmt INTO \`$table\`
		      SELECT $cols_list FROM \`$table\` WHERE corpus='$source_u';"
	    fi
	fi
    done
}

mysql_make_manage_rel_tables () {
    local cmd source_u target_u tabletype source_table target_table
    cmd=$1
    source_u=$2
    target_u=$3
    for tabletype in "" _dep_rel _head_rel _rel _sentences _strings; do
	source_table=relations_$source_u$tabletype
	target_table=relations_$target_u$tabletype
	if mysql_table_exists $source_table; then
	    if [ "$cmd" = "remove" ]; then
		echo "DROP TABLE IF EXISTS \`$source_table\`;"
	    else
		echo "DROP TABLE IF EXISTS \`$target_table\`;"
		if [ "$cmd" = "rename" ]; then
		    echo "RENAME TABLE \`$source_table\` TO \`$target_table\`;"
		elif [ "$cmd" = "copy" ]; then
		    echo "CREATE TABLE IF NOT EXISTS \`$target_table\` LIKE \`$source_table\`;"
		    echo "INSERT IGNORE INTO \`$target_table\` SELECT * FROM \`$source_table\`;"
		fi
	    fi
	fi
    done
}

run_mysql_verb () {
    local tmpfile dbname
    tmpfile=$tmpprefix.mysql
    cat > $tmpfile
    if [ "x$1" = "x--auth" ]; then
	dbname=korp_auth
    else
	dbname=korp
    fi
    run_verb "Executing MySQL statements on database $dbname:
$(indent_input 4 < $tmpfile)" \
	     run_mysql "$@" < $tmpfile
}

manage_database () {
    local cmd source target source_u target_u
    cmd=$1
    source=$2
    target=$3
    source_u=$(toupper $source)
    target_u=$(toupper $target)
    # $target_u is empty for remove, but mysql_make_manage_table_rows
    # expects three arguments before table names, so enclose it in
    # quotes to avoid leaving out the first table name.
    {
	mysql_make_manage_table_rows $cmd $source_u "$target_u" \
				     $multicorpus_tables
	mysql_make_manage_rel_tables $cmd $source_u $target_u
    } |
	run_mysql_verb
    mysql_make_manage_table_rows $cmd $source_u "$target_u" \
				 $multicorpus_tables_auth |
	run_mysql_verb --auth
}

manage_corpus () {
    local cmd source target target_bak msg
    cmd=$1
    source=$2
    target=$3
    if [ "$source" = "$target" ]; then
	warn "Skipping corpus $source: target is the same"
	return
    fi
    if ! corpus_exists "$source"; then
	warn "Skipping corpus $source: not found in registry $cwb_regdir"
	return
    fi
    if [ "$cmd" != "remove" ]; then
        if ! corpus_id_is_valid $target; then
	    warn "Skipping corpus $source: invalid target corpus id: $target"
	    return
	elif corpus_exists $target; then
	    if [ "x$force" = x ]; then
		warn "Skipping corpus $source: target corpus $target already exists; specify --force to overwrite"
		return
	    elif [ "x$baksuff" = x ]; then
		warn "Corpus $source: overwriting existing target corpus $target without making a backup as --force and --backup-suffix=\"\" were specified"
		# Removing the existing target is probably needed for
		# the MySQL database statements to work correctly
		manage_corpus remove $target
	    else
		target_bak=$target$baksuff
		warn "Corpus $source: renaming existing target corpus $target to $target_bak before overwriting as --force was specified"
		manage_corpus rename $target $target_bak
	    fi
	fi
    fi
    if [ "x$verbose" != x ]; then
	msg="$cmd_verb corpus $source"
	if [ "x$dry_run" != x ]; then
	    msg="Dry run: $msg"
	fi
	if [ "$cmd" != "remove" ]; then
	    msg="$msg to $target"
	fi
	safe_echo "$msg"
    fi
    manage_data $cmd $source $target
    manage_registry $cmd $source $target
    manage_database $cmd $source $target
}


for corpus in $corpora; do
    if [ "$command" = "remove" ]; then
	target=
    elif [ "x$substpatt" != x ]; then
	target=$(echo "$corpus" | perl -pe "$substpatt")
    else
	target=$target_corpus
    fi
    manage_corpus $command $corpus $target
done
