#! /usr/bin/env python
# -*- coding: utf-8 -*-


# Output a Korp corpus configuration based on the following
# information:
#
# - Corpus attribute information from cwb-describe-corpus
# - Configuration file (INI-style)
# - A content file (TSV or CSV) for making configurations of multiple
#   similar corpora.
# - Possible Korp JavaScript configuration files to add the new
#   configuration directly
# - Later possibly cwb-lexdecode, cwb-s-decode to get attribute values
#   for dataset properties.


import sys
import re
import csv

import korpimport.util
import korpimport.cwbutil as cwb


class CorpusConfig(object):

    _corpus_props_basic = [
        ('id', 'str', 'required'),
        ('title', 'str', 'required'),
        ('description', 'str', 'recommended'),
        ('urn', 'str', 'recommended'),
        ('metadata_urn', 'str', 'recommended'),
        ('homepage_url', 'str', 'optinal'),
        ('licence', 'obj', 'recommended'),
    ]
    _prop_value_default = {
        'str': '""',
        'obj': '{}'
    }
    _corpus_feature_attrs = {
        'paragraphs': {
            'struct': ['paragraph'],
        },
        'parsed_tdt': {
            'pos': ['lemma', 'lemmacomp', 'pos', 'msd', 'dephead', 'deprel',
                    'ref', 'lex'],
        },
        'finer': {
            'pos': ['nertag', 'nerbio'],
            'struct': ['ne_name', 'ne_ex', 'ne_type', 'ne_subtype',
                       'ne_fulltype', 'ne_placename', 'ne_placename_source'],
        },
    }
    _corpus_feature_attr_order = ['paragraphs', 'parsed_tdt', 'finer']
    # _corpus_attr_props contains triples of attribute type (as
    # returned by CWBCorpusInfo), JavaScript property name for the
    # attribute type in the Korp configuration, and a filter function
    # that returns True for the attributes to be included in the
    # configuration.
    _corpus_attr_props = [
        ('pos', 'attributes', lambda attr: attr['name'] != 'word'),
        ('struct', 'struct_attributes',
         lambda attr: ('_' in attr['name']
                       and not re.match(r'text_(date|time)(from|to)',
                                        attr['name']))),
    ]
    _default_attr_props = ['label']

    def __init__(self, corpus_info, attr_prop_values=None,
                 required_msg_fn=None, recommended_msg_fn=None):
        self._basic_corpus_info = {}
        self._attr_prop_values = attr_prop_values or {}
        self._corpus_config = []
        self._init_basic_corpus_info(corpus_info,
                                     required_msg_fn=required_msg_fn,
                                     recommended_msg_fn=recommended_msg_fn)
        self._init_config(corpus_info)

    def get_id(self):
        return self._basic_corpus_info['id'].strip('"')

    def get_config(self):
        return self._corpus_config

    def _init_basic_corpus_info(self, corpus_info, required_msg_fn=None,
                                recommended_msg_fn=None):
        self._basic_corpus_info = {}
        for propname, proptype, required in self._corpus_props_basic:
            propval = corpus_info.get(propname)
            if propval is None:
                if required == 'required':
                    required_msg_fn('Please specify corpus ' + propname)
                elif required == 'recommended':
                    recommended_msg_fn('No corpus ' + propname + ' specified')
                    propval = self._prop_value_default[proptype]
            elif proptype == 'str' and propval[0] != '"':
                propval = '"' + propval + '"'
            if propval is not None:
                self._basic_corpus_info[propname] = propval

    def _init_config(self, corpus_info):
        corpus_id = self._basic_corpus_info['id'].strip('"')
        corpus_info = cwb.CWBCorpusInfo(corpus_id)
        for key, _, _ in self._corpus_props_basic:
            value = self._basic_corpus_info.get(key)
            if value is not None:
                self._corpus_config.append((key, value))
        self._corpus_config.append(self._make_corpus_features(corpus_info))
        self._corpus_config.extend(self._make_attrs(corpus_info))

    def _make_corpus_features(self, corpus_info, other_feats=None):
        feats = []
        feats.extend(other_feats or [])
        for feat in self._corpus_feature_attr_order:
            feat_attrs = self._corpus_feature_attrs[feat]
            corpus_has_all_feat_attrs = True
            for attrtype, attrnames in feat_attrs.iteritems():
                attrtype1 = attrtype[0]
                if not all(attrname in corpus_info.attrdict
                           and (corpus_info.attrdict[attrname]['type']
                                == attrtype1)
                           for attrname in attrnames):
                    corpus_has_all_feat_attrs = False
                    break
            if corpus_has_all_feat_attrs:
                feats.append(feat)
                feat_attrs_set = set(featname
                                     for featnames in feat_attrs.itervalues()
                                     for featname in featnames)
                for attrtype in feat_attrs.iterkeys():
                    attrtype1 = attrtype[0]
                    attrs = corpus_info.attributes[attrtype1]
                    attrs[:] = (attr for attr in attrs
                                if attr['name'] not in feat_attrs_set)
        return ('features',
                '[' + ', '.join('"' + feat + '"' for feat in feats) + ']')

    def _make_attrs(self, corpus_info):
        result = []
        for attrtype, attrs_propname, filter_fn in self._corpus_attr_props:
            attrlist = []
            for attr in corpus_info.attributes[attrtype]:
                if filter_fn(attr):
                    result_attr_props = []
                    attrname = attr['name']
                    attr_props = self._attr_prop_values.get(attrname, [])
                    propnames = set(propname for propname, _ in attr_props)
                    for attr_prop in attr_props:
                        result_attr_props.append(attr_prop)
                    result_attr_props.extend(
                        (attrpropname, '""')
                        for attrpropname in self._default_attr_props
                        if  attrpropname not in propnames)
                    attrlist.append((attrname, result_attr_props))
            if attrlist:
                result.append((attrs_propname, attrlist))
        return result


class CorpusConfigMaker(korpimport.util.OptionRunner):

    def __init__(self, args=None):
        # No input nor output encoding: use UTF-8 byte strings
        # internally instead of unicode.
        super(CorpusConfigMaker, self).__init__(input_encoding=None,
                                                output_encoding=None)

    def main(self, *args, **kwargs):
        if not self._opts.corpus_id and not self._opts.corpus_list_file:
            self._error('Please specify corpus id')
        self._make_attr_prop_values()
        self._make_basic_corpus_info()
        if self._opts.corpus_list_file:
            self._read_corpus_list_file()
        else:
            self._corpus_info = [self._basic_corpus_info]
        for corpus_info in self._corpus_info:
            self.output(self._format_corpus_config(self._make_corpus_config(
                corpus_info)) + '\n')

    def _make_attr_prop_values(self):
        self._attr_prop_values = {}
        for labelinfo in self._opts.attribute_label or []:
            attrname, label = re.split(r'\s*[:=]\s*', labelinfo, 1)
            self._attr_prop_values[attrname] = [('label', '"' + label + '"')]

    def _make_basic_corpus_info(self):
        prefix = 'corpus_'
        prefix_len = len(prefix)
        self._basic_corpus_info = dict(
            (optname[prefix_len:], getattr(self._opts, optname))
            for optname in dir(self._opts) if optname.startswith(prefix))

    def _read_corpus_list_file(self):
        csv_reader_kwargs = dict()
        if self._opts.corpus_list_file.endswith('.tsv'):
            csv_reader_kwargs = dict(delimiter='\t',
                                     quoting=csv.QUOTE_NONE)
        self._corpus_info = []
        with open(self._opts.corpus_list_file) as f:
            prefix = 'corpus_'
            prefix_len = len(prefix)
            reader = csv.DictReader(f, **csv_reader_kwargs)
            reader.fieldnames[:] = [
                name[prefix_len:] if name.startswith(prefix) else name
                for name in reader.fieldnames]
            for row in reader:
                # print repr(row)
                info = {}
                info.update(self._basic_corpus_info)
                info.update(row)
                self._corpus_info.append(info)

    def _make_corpus_config(self, corpus_info):
        return CorpusConfig(corpus_info,
                            attr_prop_values=self._attr_prop_values,
                            required_msg_fn=self.error,
                            recommended_msg_fn=self.warn)

    def _format_corpus_config(self, corpus_config):
        return ('settings.corpora.' + corpus_config.get_id() + ' = {\n'
                + self._format_js_props(corpus_config.get_config())
                + '\n};\n')

    def _format_js_props(self, props, indent=0):
        return '\n'.join(self._format_js_prop(propname, propval, indent + 4)
                          for propname, propval in props)

    def _format_js_prop(self, name, value, indent=4):
        if isinstance(value, basestring):
            formatted_value = value
        elif value == []:
            formatted_value = '{}'
        else:
            formatted_value = ('{\n' + self._format_js_props(value, indent)
                               + '\n' + (indent * ' ') + '}')
        return (indent * ' ') + name + ': ' + formatted_value + ','

    def getopts(self, args=None):
        self.getopts_basic(
            dict(usage="%progname [corpus] > output",
                 description=(
"""Generate a Korp frontend JavaScript configuration for an encoded corpus.""")
             ),
            args,
            ['corpus-id id = CORPUS', dict(
                help=(''))],
            ['corpus-name name corpus-title title = NAME', dict(
                dest='corpus_title',
                help=(''))],
            ['corpus-description description = DESCR', dict(
                help=(''))],
            ['corpus-urn urn = URN', dict(
                help=(''))],
            ['corpus-metadata-urn metadata-urn = URN', dict(
                help=(''))],
            ['corpus-homepage-url homepage-url = URL', dict(
                help=(''))],
            ['corpus-licence licence = LICENCE', dict(
                help=(''))],
            ['corpus-list-file list-file = FILE', dict(
                help="""read from the CSV or TSV file FILE information on the
                corpora whose configurations to generate. The first
                line of the file lists the property names
                corresponding to the options above (with or without
                the prefix "corpus_" and with dashes converted to
                underscores). If the file name ends in ".tsv", it is
                considered as a tab-separated values file, otherwise a
                CSV file.""")],
            ['attribute-label label = ATTRNAME:LABEL', dict(
                action='append',
                help=('use LABEL as the value of property "label" of'
                      ' attribute ATTRNAME; the option may be specified'
                      ' multiple times to give labels for multiple'
                      ' attributes'))]
        )
        

if __name__ == "__main__":
    CorpusConfigMaker().run()
