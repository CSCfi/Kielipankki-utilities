#! /usr/bin/env python3
# -*- mode: Python; -*-

from itertools import groupby, chain
import enum, os, re, sys, traceback

from vrtargslib import trans_args, trans_main
from vrtargslib import BadData, BadCode
from vrtnamelib import isbinnames, binmakenames

def spectype(text):
    if re.fullmatch(R'[\w.]+=[\w.]+', text):
        return text.encode('UTF-8').split(b'=')
    raise ArgumentTypeError('malformed specification: {}'
                            .format(text))

def parsearguments():
    description = '''

    Rename some positional attributes.

    '''

    parser = trans_args(description = description)

    parser.add_argument('--map', '-m', metavar = 'old=new',
                        dest = 'mapping', action = 'append',
                        type = spectype, default = [],
                        help = 'map old name to new name')
    args = parser.parse_args()
    args.prog = parser.prog
    return args

class Kind(enum.Enum):
    # kind of line (group of them)
    meta = 1
    data = 2
    begin = 3
    names = 4
    comment = 5

def identify(line):
    # used by groupby to identify the kind of a line group
    if line.startswith(b'<!--'):
        if isbinnames(line): return Kind.names
        else: return Kind.comment
    if line.startswith(b'<sentence'): return Kind.begin
    if line.startswith(b'<'): return Kind.meta
    return Kind.data

def makenew(old, args):
    names = re.findall(br'[\w.+]+', old)[2:]
    rep = dict(args.mapping)
    for name in rep:
        if name not in names:
            raise BadData('error: not an old name: ' + name.decode('UTF-8'))
    
    new = [ rep.get(name, name) for name in names ]

    if len(set(new)) < len(new):
        raise BadData('error: duplicate names')

    return binmakenames(*new)

def main(args, inf, ouf):
    status = 1
    try:
        implement_main(inf, ouf, args)
        status = 0
    except BadData as exn:
        print(args.prog + ':', exn, file = sys.stderr)
    except BadCode as exn:
        print(args.prog + ':', exn, file = sys.stderr)
    except BrokenPipeError:
        print(args.prog + ': broken pipe in main', file = sys.stderr)
    except Exception as exn:
        print(traceback.format_exc(), file = sys.stderr)

    return status

def implement_main(inf, ouf, args):

    seen = False
    def isnotspace(line): return not line.isspace()
    for kind, group in groupby(filter(isnotspace, inf), identify):

        if kind is Kind.data:
            for line in group: ouf.write(line)
            continue

        if kind is Kind.begin:
            if not seen:
                raise BadData('error: no names before sentence')
            for line in group: ouf.write(line)
            continue

        if kind is Kind.meta:
            for line in group: ouf.write(line)
            continue

        if kind is Kind.data:
            for line in group: ouf.write(line)
            continue

        if kind is Kind.names:
            seen = True
            for line in group: ouf.write(makenew(line, args))
            continue

        if kind is Kind.comment:
            for line in group: ouf.write(line)
            continue

        raise BadCode('this cannot happen')

if __name__ == '__main__':
    trans_main(parsearguments(), main,
               in_as_text = False,
               out_as_text = False)
