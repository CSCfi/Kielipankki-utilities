#! /usr/bin/env python3
# -*- coding: utf-8 -*-


# TODO:
# - Add an option not to decode encoded vertical bars in feature set
#   attributes to allow correct round-trip conversion.


import sys
import re
import errno

from vrtargsoolib import InputProcessor

from vrtnamelib import isbinnames, binnamelist


def replace_substrings(s, mapping):
    """Replace substrings in s according to mapping (a sequence of
    pairs (string, replacement): replace each string with the
    corresponding replacement.
    """
    for (s1, repl) in mapping:
        s = s.replace(s1, repl)
    return s


class CharConverter(InputProcessor):

    DESCRIPTION = """
    Encode or decode in VRT files special characters that are
    problematic in CWB.
    """
    ARGSPECS = [
        ('#EXCLUSIVE #REQUIRED', [
            ('--encode',
             'encode special characters',
             dict(action='store_const', dest='mode', const='encode')),
            ('--decode',
             'decode encoded special characters',
             dict(action='store_const', dest='mode', const='decode')),
        ]),
        ('--chars = chars',
         'the characters to be converted in their unencoded form',
         dict(default=" /<>|")),
        ('--offset = offset "0x7F"',
         '''the code point offset for the encoded characters: the first
            character in CHARS is encoded as OFFSET, the second as
            OFFSET+1 and so on'''),
        ('--feature-set-struct-attributes|set-struct-attrs = attrspec',
         '''Treat the structural attributes specified in the attribute
            specification ATTRSPEC as feature-set attributes and do
            not convert the vertical bar characters in them. ATTRSPEC
            is a space-separated list of element definitions, of the
            form ELEMNAME_ATTRNAME, ELEMNAME:ATTRNAMELIST or
            ELEMNAME:N+ATTRNAMELIST, where ELEMNAME is the name of the
            XML element, ATTRNAME is a single attribute name and
            ATTRNAMELIST is a list of attribute names separated by
            commas or pluses. The third form corresponds to a
            structural attribute specification for cwb-encode where N
            is a non-negative integer (ignored), and the feature-set
            attribute names in ATTRNAMELIST must be suffixed by a
            slash; others are ignored. In contrast, in the second
            form, all the attributes listed in ATTRLIST are considered
            feature-set attributes regardless of whether they end in a
            slash or not. For example, the values "elem_attr1
            elem_attr2", "elem:attr1,attr2" and
            "elem:0+attr0+attr1/+attr2/" are equivalent. This option
            can be repeated. (default: none)''',
         dict(action='append', default=[]))
    ]

    _xml_char_entities = {
        b'&': b'&amp;',
        b'<': b'&lt;',
        b'>': b'&gt;',
        b'\'': b'&apos;',
        b'"': b'&quot;'
    }

    def __init__(self):
        super().__init__()
        # Initialized in check_args
        self._convert_map = None
        self._convert_map_featset = None
        self._feat_set_attrs = set()
        self._feat_set_struct_attrs = None
        self._convert_chars_in_pos_attrs = None
        self._convert_chars_in_struct_attrs = None
        self._struct_re = r'<.+>\s*$'

    def check_args(self, args):
        args.offset = int(args.offset, base=0)
        self._convert_map = [(c.encode(), chr(i + args.offset).encode())
                             for (i, c) in enumerate(args.chars)]
        self._add_xml_char_refs_to_convert_map(args.mode)
        self._feat_set_struct_attrs = self._make_feat_set_struct_attrs(
            args.feature_set_struct_attributes)
        # print repr(self._feat_set_struct_attrs)
        if args.mode == 'decode':
            self._convert_map = [(enc, dec) for dec, enc in self._convert_map]
        # This is modified in _get_feat_set_pos_attrs after seeing a
        # positional-attributes comment with feature-set attributes
        self._convert_chars_in_pos_attrs = self._convert_chars
        if args.mode == 'encode' and self._feat_set_struct_attrs:
            self._convert_chars_in_struct_attrs = (
                self._convert_chars_in_struct_attrs_featsets)
        else:
            self._convert_chars_in_struct_attrs = (
                self._convert_chars_in_struct_attrs_simple)
        self._convert_map_featset = [
            (dec, enc) for dec, enc in self._convert_map if dec != b'|']

    def _make_feat_set_struct_attrs(self, feat_set_struct_attrs):
        set_struct_attrs = {}
        for attr_spec_list in (feat_set_struct_attrs or []):
            for attr_spec in attr_spec_list.split():
                attr_spec = attr_spec
                if ':' in attr_spec:
                    elemname, attrnames_str = attr_spec.split(':', 1)
                    attrnames = re.split(r'[,+]', attrnames_str)
                    # A structural attribute specification for
                    # cwb-encode, recognized from the first element
                    # being numeric: only take the attribute names
                    # ending in a slash
                    if attrnames[0].isdigit():
                        attrnames = [attrname[:-1] for attrname in attrnames[1:]
                                     if attrname[-1] == '/']
                    else:
                        # Otherwise, allow but do not require a
                        # trailing slash
                        attrnames = [
                            attrname.strip('/') for attrname in attrnames]
                elif '_' in attr_spec:
                    elemname, attrname = attr_spec.split('_', 1)
                    attrnames = [attrname]
                if attrnames:
                    elem_attrs = set_struct_attrs.setdefault(
                        elemname.encode(), set())
                    elem_attrs |= set(attrname.encode()
                                      for attrname in attrnames)
        return set_struct_attrs

    def _add_xml_char_refs_to_convert_map(self, mode):
        if mode == 'encode':
            # When encoding, replace both literal characters and
            # XML character entity references with the encoded
            # characters.
            self._convert_map.extend(
                (self._xml_char_entities[c1], c2)
                for c1, c2 in self._convert_map
                if c1 in self._xml_char_entities)
        else:
            # When decoding, replace the appropriate converted
            # characters with XML character entity references and
            # not the literal characters. The conversion map will
            # be inverted only after this.
            self._convert_map = [
                (self._xml_char_entities.get(c1, c1), c2)
                for c1, c2 in self._convert_map]

    def main(self, args, inf, ouf):
        LESS_THAN = b'<'[0]
        check_pos_attrs_comment = (args.mode == 'encode')
        for line in inf:
            if line[0] == LESS_THAN:
                # Note: This does not skip multi-line XML comments, as
                # cwb-encode does not recognize them
                if line[1] not in b'!?':
                    line = self._convert_chars_in_struct_attrs(line)
                elif check_pos_attrs_comment and isbinnames(line):
                    self._get_feat_set_pos_attrs(line)
                    check_pos_attrs_comment = False
            else:
                line = self._convert_chars_in_pos_attrs(line)
            ouf.write(line)

    def _get_feat_set_pos_attrs(self, line):
        attrnames = binnamelist(line)
        for idx, attrname in enumerate(attrnames):
            if attrname[-1] == b'/'[0]:
                self._feat_set_attrs.add(idx)
        if self._feat_set_attrs:
            self._convert_chars_in_pos_attrs = (
                self._convert_chars_in_pos_attrs_featsets)

    def _convert_chars(self, s, convert_map=None):
        """Encode the special characters in s."""
        return replace_substrings(s, convert_map or self._convert_map)

    def _convert_chars_in_pos_attrs_featsets(self, s):
        attrs = s.split(b'\t')
        for attrnum, attr in enumerate(attrs):
            attrs[attrnum] = replace_substrings(
                attr, (self._convert_map_featset
                       if attrnum in self._feat_set_attrs
                       else self._convert_map))
        return b'\t'.join(attrs)

    def _convert_chars_in_struct_attrs_simple(self, s):
        """Encode the special characters in the double-quoted
        substrings of s.
        """
        return re.sub(br'(".*?")',
                      lambda mo: self._convert_chars(mo.group(0)), s)

    def _convert_chars_in_struct_attrs_featsets(self, s):

        def convert_attr(mo, convert_map=None, elemname=None):
            convert_map = convert_map or (
                self._convert_map_featset
                if (mo.group(1) in self._feat_set_struct_attrs.get(elemname,
                                                                   set()))
                else self._convert_map)
            return (mo.group(1) + b'='
                    + self._convert_chars(mo.group(2), convert_map))

        elemname = re.search(br'(\w+)', s).group(1)
        convert_map = (None if elemname in self._feat_set_struct_attrs
                       else self._convert_map)
        # print elemname, convert_map
        return re.sub(br'(\w+)=(".*?")',
                      lambda mo: convert_attr(mo, convert_map, elemname), s)


if __name__ == "__main__":
    CharConverter().run()
