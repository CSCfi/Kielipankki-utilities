#! /usr/bin/env python3
# -*- coding: utf-8 -*-


# TODO:
# - Add an option not to decode encoded vertical bars in feature set
#   attributes to allow correct round-trip conversion.


import sys
import re
import errno

from vrtargsoolib import InputProcessor



def replace_substrings(s, mapping):
    """Replace substrings in s according to mapping (a sequence of
    pairs (string, replacement): replace each string with the
    corresponding replacement.
    """
    for (s1, repl) in mapping:
        s = s.replace(s1, repl)
    return s


class CharConverter(InputProcessor):

    DESCRIPTION = """
    Encode or decode in VRT files special characters that are
    problematic in CWB.
    """
    ARGSPECS = [
        ('#EXCLUSIVE #REQUIRED', [
            ('--encode',
             'encode special characters',
             dict(action='store_const', dest='mode', const='encode')),
            ('--decode',
             'decode encoded special characters',
             dict(action='store_const', dest='mode', const='decode')),
        ]),
        ('--chars = chars',
         'the characters to be converted in their unencoded form',
         dict(default=" /<>|")),
        ('--offset = offset "0x7F"',
         '''the code point offset for the encoded characters: the first
            character in CHARS is encoded as OFFSET, the second as
            OFFSET+1 and so on'''),
        ('--feature-set-attributes = attrnumlist',
         '''do not encode vertical bars in positional attributes whose
            numbers are listed in ATTRNUMLIST, separated by spaces or
            commas; attribute numbering begins from 1'''),
        ('--feature-set-struct-attributes|set-struct-attrs = attrspec',
         '''Treat the structural attributes specified in the attribute
            specification ATTRSPEC as feature-set attributes and do
            not convert the vertical bar characters in them. ATTRSPEC
            is a space-separated list of element definitions, of the
            form ELEMNAME_ATTRNAME, ELEMNAME:ATTRNAMELIST or
            ELEMNAME:N+ATTRNAMELIST, where ELEMNAME is the name of the
            XML element, ATTRNAME is a single attribute name and
            ATTRNAMELIST is a list of attribute names separated by
            commas or pluses. The third form corresponds to a
            structural attribute specification for cwb-encode where N
            is a non-negative integer (ignored), and the feature-set
            attribute names in ATTRNAMELIST must be suffixed by a
            slash; others are ignored. In contrast, in the second
            form, all the attributes listed in ATTRLIST are considered
            feature-set attributes regardless of whether they end in a
            slash or not. For example, the values "elem_attr1
            elem_attr2", "elem:attr1,attr2" and
            "elem:0+attr0+attr1/+attr2/" are equivalent. This option
            can be repeated. (default: none)''',
         dict(action='append', default=[]))
    ]

    class OPTIONS(InputProcessor.OPTIONS):
        in_as_text = True
        out_as_text = True

    _xml_char_entities = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '\'': '&apos;',
        '"': '&quot;'
        }

    def __init__(self):
        super().__init__()
        # Initialized in check_args
        self._convert_map = None
        self._convert_map_featset = None
        self._feat_set_attrs = None
        self._feat_set_struct_attrs = None
        self._convert_chars_in_pos_attrs = None
        self._convert_chars_in_struct_attrs = None
        self._struct_re = r'<.+>\s*$'

    def check_args(self, args):
        args.offset = int(args.offset, base=0)
        self._convert_map = [(c, chr(i + args.offset))
                             for (i, c) in enumerate(args.chars)]
        self._add_xml_char_refs_to_convert_map(args.mode)
        self._feat_set_attrs = set(
            self._make_attr_list(args.feature_set_attributes))
        self._feat_set_struct_attrs = self._make_feat_set_struct_attrs(
            args.feature_set_struct_attributes)
        # print repr(self._feat_set_struct_attrs)
        if args.mode == 'decode':
            self._convert_map = [(enc, dec) for dec, enc in self._convert_map]
        if args.mode == 'encode' and self._feat_set_attrs:
            self._convert_chars_in_pos_attrs = (
                self._convert_chars_in_pos_attrs_featsets)
        else:
            self._convert_chars_in_pos_attrs = self._convert_chars
        if args.mode == 'encode' and self._feat_set_struct_attrs:
            self._convert_chars_in_struct_attrs = (
                self._convert_chars_in_struct_attrs_featsets)
        else:
            self._convert_chars_in_struct_attrs = (
                self._convert_chars_in_struct_attrs_simple)
        self._convert_map_featset = [
            (dec, enc) for dec, enc in self._convert_map if dec != '|']

    def _make_attr_list(self, attrnumlist):
        if attrnumlist:
            return [int(numstr) - 1
                    for numstr in re.split(r'\s*[\s,]\s*', attrnumlist)]
        else:
            return []

    def _make_feat_set_struct_attrs(self, feat_set_struct_attrs):
        set_struct_attrs = {}
        for attr_spec_list in (feat_set_struct_attrs or []):
            for attr_spec in attr_spec_list.split():
                if ':' in attr_spec:
                    elemname, attrnames_str = attr_spec.split(':', 1)
                    attrnames = re.split(r'[,+]', attrnames_str)
                    # A structural attribute specification for
                    # cwb-encode, recognized from the first element
                    # being numeric: only take the attribute names
                    # ending in a slash
                    if attrnames[0].isdigit():
                        attrnames = [attrname[:-1] for attrname in attrnames[1:]
                                     if attrname[-1] == '/']
                    else:
                        # Otherwise, allow but do not require a
                        # trailing slash
                        attrnames = [
                            attrname.strip('/') for attrname in attrnames]
                elif '_' in attr_spec:
                    elemname, attrname = attr_spec.split('_', 1)
                    attrnames = [attrname]
                if attrnames:
                    elem_attrs = set_struct_attrs.setdefault(elemname, set())
                    elem_attrs |= set(attrnames)
        return set_struct_attrs

    def _add_xml_char_refs_to_convert_map(self, mode):
        if mode == 'encode':
            # When encoding, replace both literal characters and
            # XML character entity references with the encoded
            # characters.
            self._convert_map.extend(
                (self._xml_char_entities[c1], c2)
                for c1, c2 in self._convert_map
                if c1 in self._xml_char_entities)
        else:
            # When decoding, replace the appropriate converted
            # characters with XML character entity references and
            # not the literal characters. The conversion map will
            # be inverted only after this.
            self._convert_map = [
                (self._xml_char_entities.get(c1, c1), c2)
                for c1, c2 in self._convert_map]

    def main(self, args, inf, ouf):
        for line in inf:
            if line[0] == '<':
                # Note: This does not skip multi-line XML comments, as
                # cwb-encode does not recognize them
                if line[1] not in '!?':
                    line = self._convert_chars_in_struct_attrs(line)
            else:
                line = self._convert_chars_in_pos_attrs(line)
            ouf.write(line)

    def _convert_chars(self, s, convert_map=None):
        """Encode the special characters in s."""
        return replace_substrings(s, convert_map or self._convert_map)

    def _convert_chars_in_pos_attrs_featsets(self, s):
        attrs = s.split('\t')
        for attrnum, attr in enumerate(attrs):
            attrs[attrnum] = replace_substrings(
                attr, (self._convert_map_featset
                       if attrnum in self._feat_set_attrs
                       else self._convert_map))
        return '\t'.join(attrs)

    def _convert_chars_in_struct_attrs_simple(self, s):
        """Encode the special characters in the double-quoted
        substrings of s.
        """
        return re.sub(r'(".*?")',
                      lambda mo: self._convert_chars(mo.group(0)), s)

    def _convert_chars_in_struct_attrs_featsets(self, s):

        def convert_attr(mo, convert_map=None, elemname=None):
            convert_map = convert_map or (
                self._convert_map_featset
                if (mo.group(1) in self._feat_set_struct_attrs.get(elemname,
                                                                   set()))
                else self._convert_map)
            return (mo.group(1) + "="
                    + self._convert_chars(mo.group(2), convert_map))

        elemname = re.search(r'(\w+)', s).group(1)
        convert_map = (None if elemname in self._feat_set_struct_attrs
                       else self._convert_map)
        # print elemname, convert_map
        return re.sub(r'(\w+)=(".*?")',
                      lambda mo: convert_attr(mo, convert_map, elemname), s)


if __name__ == "__main__":
    CharConverter().run()
