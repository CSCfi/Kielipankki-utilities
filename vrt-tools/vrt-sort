#! /usr/bin/env python3
# -*- mode: Python; -*-


"""
vrt-sort

Sort text structures within VRT input by creating a sort key from text
attribute values and using the Unix sort command to sort according to the key.

The script uses the GNU/Unix "sort" command to do the actual sorting and "cut"
to remove the sort key.
"""


# TODO:
# - Allow transforming key values
# - Allow sorting e.g. paragraphs or sentences within texts


import os
import re
import sys

from subprocess import Popen, PIPE, TimeoutExpired
from time import sleep

from vrtargsoolib import InputProcessor


class VrtSorter(InputProcessor):

    """Sort text structures within VRT input."""

    DESCRIPTION = """
    Sort text structures within the input VRT according to the values
    of given attributes.
    """
    ARGSPECS = [
        ('--key|attribute = attrlist',
         '''use attributes listed in attrlist (separated by spaces) as
            the sort keys: sort primarily by the first attribute,
            secondarily by the second and so on. Each attribute name
            may be followed by a colon and sort ordering option
            characters recognized by the "sort" command: often one or
            more of the following: b (ignore leading blanks), d
            (dictionary order), f (ignore case), g (general numeric
            sort), i (ignore nonprinting), M (month sort), h (human
            numeric sort), R (random sort), r (reverse), V (version
            sort).''',
         {'required': True}),
    ]

    def __init__(self):
        super().__init__()
        self._key_attrs = []
        self._key_attr_count = 0
        self._key_re = None
        self._make_key = None
        self._sorter_key_opts = None

    def check_args(self, args):
        super().check_args(args)
        keys = [key.partition(':') for key in args.key.split()]
        self._key_attrs = [key[0].encode() for key in keys]
        key_opts = [key[2] for key in keys]
        self._key_attr_count = len(keys)
        if len(keys) == 1:
            self._make_key = self._make_key_single
            self._key_re = re.compile(b' ' + self._key_attrs[0] + rb'="(.*?)"')
        else:
            self._make_key = self._make_key_multi
            self._key_re = re.compile(rb' ([\w-]+)="(.*?)"')
        # The first key field indicates whether the line is part of the top
        # comments (before the first text), the body or the bottom comments
        # (after the last text). Sorting would be faster if it were prefixed to
        # the first key field, but it would not work with all sort options.
        key_opts[0:0] = ['']
        self._sorter_key_opts = ['-k{0},{0}{1}'.format(i + 1, key_opts[i])
                                for i in range(len(keys) + 1)]
        # sys.stderr.write(repr(self._key_attrs) + '\n' + repr(self._sorter_key_opts) + '\n')

    def main(self, args, inf, ouf):
        LESS_THAN = '<'.encode('utf-8')[0]
        env = os.environ
        env['LC_ALL'] = 'C'
        sorter = Popen(['sort', '-s', '-t\t'] + self._sorter_key_opts,
                       stdin=PIPE, stdout=PIPE, stderr=PIPE, bufsize=-1,
                       env=env)
        # Give sort time to start to see if it produces an error message
        sleep(0.1)
        sorter.poll()
        # TODO: Interpret the sort error message
        if sorter.returncode is not None:
            sorter_errmsg = [line.decode()[:-1] for line in sorter.stderr]
            self.error_exit('Invalid sort option; sort error message:\n'
                            + ''.join(sorter_errmsg))
        # tee = Popen(['tee', 'vrt-sort-keys.out'],
        #             stdin=sorter.stdout, stdout=PIPE, bufsize=-1)
        cutter = Popen(['cut', '-d\t',
                        '-f{0}-'.format(self._key_attr_count + 2)],
                       stdin=sorter.stdout, stdout=ouf, bufsize=-1)
        text_seen = False
        text_open = False
        comments = []
        key = ''
        # Tabs to be added between the primary key and top or bottom comment
        # lines
        comment_tabs = (self._key_attr_count + 1) * b'\t'
        for line in inf:
            if text_open:
                if line[0] == LESS_THAN and line.startswith(b'</text>'):
                    text_open = False
                sorter.stdin.write(key + line)
            else:
                if line[0] == LESS_THAN:
                    if line.startswith(b'<text '):
                        # Prepend "1" to the key value to sort the data between
                        # the top and bottom comments
                        key = b'1\t' + self._make_key(line) + b'\t'
                        if comments:
                            if text_seen:
                                # Prepend comments between texts to
                                # the following text
                                comment_prefix = key
                            else:
                                # Preserve comments before the first
                                # text at the top of the output by
                                # using key "0"
                                comment_prefix = b'0' + comment_tabs
                            for comment in comments:
                                sorter.stdin.write(comment_prefix + comment)
                            comments = []
                        text_open = text_seen = True
                        sorter.stdin.write(key + line)
                    elif line.startswith(b'<!'):
                        comments.append(line)
        if comments:
            # Preserve comments after the last text at the end of the output
            # (key "2")
            for comment in comments:
                sorter.stdin.write(b'2' + comment_tabs + comment)
        sorter.stdin.close()
        # Is waiting needed? It is said to block but does it in practice in
        # this case?
        for proc in [sorter, cutter]:
            proc.wait()

    def _make_key_single(self, tagline):
        mo = self._key_re.search(tagline)
        return mo.group(1) if (mo and mo.group(1) is not None) else b''

    def _make_key_multi(self, tagline):
        attrvals = dict(self._key_re.findall(tagline))
        return b'\t'.join(attrvals.get(attrname, b'')
                          for attrname in self._key_attrs)


if __name__ == '__main__':
    VrtSorter().run()
