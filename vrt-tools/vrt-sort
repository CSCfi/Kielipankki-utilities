#! /usr/bin/env python3
# -*- mode: Python; -*-


"""
vrt-sort

Sort text structures within VRT input by creating a sort key from text
attribute values and using the Unix sort command to sort according to the key.

The script uses the GNU/Unix "sort" command to do the actual sorting and "cut"
to remove the sort key.
"""


# TODO:
# - Allow transforming key values
# - Allow sort options for keys
# - Allow sorting e.g. paragraphs or sentences within texts


import os
import re
import sys

from subprocess import Popen, PIPE

from vrtargsoolib import InputProcessor


class VrtSorter(InputProcessor):

    """Sort text structures within VRT input."""

    DESCRIPTION = """
    Sort text structures within the input VRT according to the values
    of given attributes.
    """
    ARGSPECS = [
        ('--key|attribute = attrlist',
         '''use attributes listed in attrlist (separated by spaces) as
            the sort keys: sort primarily by the first attribute,
            secondarily by the second and so on''',
        {'required': True}),
    ]

    def __init__(self):
        super().__init__()
        self._key_attrs = []
        self._key_attr_count = 0
        self._key_re = None
        self._make_key = None
        self._sorter_key_opts = None

    def check_args(self, args):
        super().check_args(args)
        keys = args.key.encode().split()
        self._key_attrs = keys
        self._key_attr_count = len(keys)
        if len(keys) == 1:
            self._make_key = self._make_key_single
            self._key_re = re.compile(b' ' + args.key.encode() + rb'="(.*?)"')
        else:
            self._make_key = self._make_key_multi
            self._key_re = re.compile(rb' ([\w-]+)="(.*?)"')
        # The first key field indicates whether the line is part of the top
        # comments (before the first text), the body or the bottom comments
        # (after the last text). Sorting would be faster if it were prefixed to
        # the first key field, but it would not work with all sort options
        # (when support for them is added).
        self._sorter_key_opts = ['-k{0},{0}'.format(i + 1)
                                 for i in range(len(keys) + 1)]

    def main(self, args, inf, ouf):
        LESS_THAN = '<'.encode('utf-8')[0]
        env = os.environ
        env['LC_ALL'] = 'C'
        sorter = Popen(['sort', '-s', '-t\t'] + self._sorter_key_opts,
                       stdin=PIPE, stdout=PIPE, bufsize=-1, env=env)
        cutter = Popen(['cut', '-d\t',
                        '-f{0}-'.format(self._key_attr_count + 2)],
                       stdin=sorter.stdout, stdout=ouf, bufsize=-1)
        text_seen = False
        text_open = False
        comments = []
        key = ''
        # Tabs to be added between the primary key and top or bottom comment
        # lines
        comment_tabs = (self._key_attr_count + 1) * b'\t'
        for line in inf:
            if text_open:
                if line[0] == LESS_THAN and line.startswith(b'</text>'):
                    text_open = False
                sorter.stdin.write(key + line)
            else:
                if line[0] == LESS_THAN:
                    if line.startswith(b'<text '):
                        # Preserve comments before the first text at the top of
                        # the output by using key "0"
                        if not text_seen and comments:
                            for comment in comments:
                                sorter.stdin.write(
                                    b'0' + comment_tabs + comment)
                            comments = []
                        # Prepend "1" to the key value to sort the data between
                        # the top and bottom comments
                        key = b'1\t' + self._make_key(line) + b'\t'
                        text_open = text_seen = True
                        sorter.stdin.write(key + line)
                    elif line.startswith(b'<!'):
                        comments.append(line)
        if comments:
            # Preserve comments after the last text at the end of the output
            # (key "2")
            for comment in comments:
                sorter.stdin.write(b'2' + comment_tabs + comment)
        sorter.stdin.close()

    def _make_key_single(self, tagline):
        mo = self._key_re.search(tagline)
        return mo.group(1) if (mo and mo.group(1) is not None) else b''

    def _make_key_multi(self, tagline):
        attrvals = dict(self._key_re.findall(tagline))
        return b'\t'.join(attrvals.get(attrname, b'')
                          for attrname in self._key_attrs)


if __name__ == '__main__':
    VrtSorter().run()
