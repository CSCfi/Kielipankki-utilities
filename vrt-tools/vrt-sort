#! /usr/bin/env python3
# -*- mode: Python; -*-


"""
vrt-sort

Sort text structures within VRT input by creating a sort key from text
attribute values and using the Unix sort command to sort according to the key.

The script uses the GNU/Unix "sort" command to do the actual sorting and "cut"
to remove the sort key.
"""


# TODO:
# - Allow sorting e.g. paragraphs or sentences within texts


import os
import re
import sys

from collections import defaultdict
from subprocess import Popen, PIPE, TimeoutExpired
from time import sleep

from vrtargsoolib import InputProcessor


class VrtSorter(InputProcessor):

    """Sort text structures within VRT input."""

    DESCRIPTION = """
    Sort text structures within the input VRT according to the values
    of given attributes.

    Comments and tags before the first <text> tag in the input are
    preserved at the top of the output and those after the last
    </text> tag at the end, so the input may have a structure spanning
    the whole input containing the text structures, but it should not
    have structures spanning multiple texts but not all of them.
    """
    ARGSPECS = [
        ('--key|attribute = attrlist',
         '''Use attributes listed in attrlist (separated by spaces or
            commas) as the sort keys: sort primarily by the first attribute,
            secondarily by the second and so on. Each attribute name
            may be followed by a colon and sort ordering option
            characters recognized by the "sort" command: often one or
            more of the following: b (ignore leading blanks), d
            (dictionary order), f (ignore case), g (general numeric
            sort), i (ignore nonprinting), M (month sort), h (human
            numeric sort), R (random sort), r (reverse), V (version
            sort).''',
         {'required': True}),
        ('--transform = attrname',
         '''Transform the value of the attribute attrname using code
            before using it as a sort key. attrname is one of the
            attributes listed in the argument of --key. code may be
            one of the following: (1) a Perl-style substitution
            "s/regexp/subst/flags" (where regexp and subst follow
            Python regular expression syntax), (2) a single Python
            expression, or (3) the body of a Python function. In (2)
            and (3), the variable "val" refers to the value of the
            attribute (str). If the body of a Python function has no
            return statement, the value of "val" is returned. The
            option may be repeated to specify transformations for
            different attributes and/or multiple transformations for a
            single attribute. Multiple transformations for an
            attribute are processed in the order they are
            specified.''',
         {'metavar': 'attrname:code',   # colon cannot be used in spec above
          'action': 'append'}),
    ]

    def __init__(self):
        super().__init__()
        self._key_attrs = []
        self._key_attrs_set = set()
        self._key_attr_count = 0
        self._key_re = None
        self._make_key = None
        self._sorter_key_opts = None
        self._transform_funcs = defaultdict(list)
        self._transform_attrs = set()

    def check_args(self, args):
        super().check_args(args)
        args.key = args.key.replace(',', ' ')
        keys = [key.partition(':') for key in args.key.split()]
        self._key_attrs = [key[0].encode() for key in keys]
        self._key_attrs_set = set(self._key_attrs)
        key_opts = [key[2] for key in keys]
        self._key_attr_count = len(keys)
        if len(keys) == 1:
            self._make_key = self._make_key_single
            self._key_re = re.compile(b' ' + self._key_attrs[0] + rb'="(.*?)"')
        else:
            self._make_key = self._make_key_multi
            self._key_re = re.compile(rb' ([\w-]+)="(.*?)"')
        # The first key field indicates whether the line is part of the top
        # comments (before the first text), the body or the bottom comments
        # (after the last text). Sorting would be faster if it were prefixed to
        # the first key field, but it would not work with all sort options.
        key_opts[0:0] = ['']
        self._sorter_key_opts = ['-k{0},{0}{1}'.format(i + 1, key_opts[i])
                                for i in range(len(keys) + 1)]
        # sys.stderr.write(repr(self._key_attrs) + '\n'
        #                  + repr(self._sorter_key_opts) + '\n')
        self._make_transforms(args.transform or [])
        self._transform_attrs = set(self._transform_funcs.keys())

    def _make_transforms(self, transforms):
        for transform in transforms:
            key, _, code = transform.partition(':')
            key = key.strip()
            key_b = key.encode()
            code = code.lstrip()
            if key_b not in self._key_attrs:
                self.error_exit('Transform attribute ' + key
                                + ' not listed in the argument of --key')
            self._transform_funcs[key_b].append(self._make_transform_func(code))
        # sys.stderr.write(repr(self._transform_funcs) + '\n')

    def _make_transform_func(self, code):

        def is_single_expr(code):
            # Use eval to check if the code is a single expression
            try:
                compile(code, '', mode='eval')
            except SyntaxError:
                return False
            return True

        def indent(lines):
            return '  ' + lines.replace('\n', '\n  ')

        body = ''
        if code.startswith('s/'):
            mo = re.match(r's/((?:[^/]|\\/)+)/((?:[^/]|\\/)*)/([gix]*)', code)
            if not mo:
                self.error_exit(f'Perl-style substitution not of the form'
                                f' s/regexp/repl/[flags]: {code}')
            regexp = mo.group(1)
            repl = mo.group(2)
            repl = re.sub(r'\$(\d)', r'\\\1', repl)
            flags = mo.group(3)
            count = 0 if 'g' in flags else 1
            flags = '|'.join('re.' + flag.upper()
                             for flag in flags if flag != 'g')
            if not flags:
                flags = '0'
            # f-strings require at least Python 3.5
            body = (f'return re.sub(r"""{regexp}""",'
                    f' r"""{repl}""", val, {count}, {flags})')
        elif is_single_expr(code):
            body = 'return ' + code
        else:
            if not re.search(r'(^|;)\s*return', code):
                body = code + '\nreturn val'
            else:
                body = code
        funcdef = 'def transfunc(val):\n' + indent(body)
        # sys.stderr.write(funcdef + '\n')
        exec(funcdef, globals())
        return transfunc

    def main(self, args, inf, ouf):
        LESS_THAN = '<'.encode('utf-8')[0]
        env = os.environ
        env['LC_ALL'] = 'C'
        sorter = Popen(['sort', '-s', '-t\t'] + self._sorter_key_opts,
                       stdin=PIPE, stdout=PIPE, stderr=PIPE, bufsize=-1,
                       env=env)
        # Give sort time to start to see if it produces an error message
        sleep(0.1)
        sorter.poll()
        # TODO: Interpret the sort error message
        if sorter.returncode is not None:
            sorter_errmsg = [line.decode()[:-1] for line in sorter.stderr]
            self.error_exit('Invalid sort option; sort error message:\n'
                            + ''.join(sorter_errmsg))
        # tee = Popen(['tee', 'vrt-sort-keys.out'],
        #             stdin=sorter.stdout, stdout=PIPE, bufsize=-1)
        cutter = Popen(['cut', '-d\t',
                        '-f{0}-'.format(self._key_attr_count + 2)],
                       stdin=sorter.stdout, stdout=ouf, bufsize=-1)
        sorter.stdout.close()
        text_seen = False
        text_open = False
        comments = []
        key = ''
        # Tabs to be added between the primary key and top or bottom comment
        # lines
        comment_tabs = (self._key_attr_count + 1) * b'\t'
        for line in inf:
            if text_open:
                if line[0] == LESS_THAN and line.startswith(b'</text>'):
                    text_open = False
                sorter.stdin.write(key + line)
            else:
                if line[0] == LESS_THAN:
                    if line.startswith(b'<text '):
                        # Prepend "1" to the key value to sort the data between
                        # the top and bottom comments
                        key = b'1\t' + self._make_key(line) + b'\t'
                        # sys.stderr.write(repr(key) + '\n')
                        if comments:
                            if text_seen:
                                # Prepend comments between texts to
                                # the following text
                                comment_prefix = key
                            else:
                                # Preserve comments (and tags) before
                                # the first text at the top of the
                                # output by using key "0"
                                comment_prefix = b'0' + comment_tabs
                            for comment in comments:
                                sorter.stdin.write(comment_prefix + comment)
                            comments = []
                        text_open = text_seen = True
                        sorter.stdin.write(key + line)
                    else:
                        comments.append(line)
        if comments:
            # Preserve comments (and tags) after the last text at the
            # end of the output (key "2")
            for comment in comments:
                sorter.stdin.write(b'2' + comment_tabs + comment)
        sorter.stdin.close()
        # Is waiting needed? It is said to block but does it in practice in
        # this case?
        for proc in [sorter, cutter]:
            proc.wait()

    def _make_key_single(self, tagline):
        mo = self._key_re.search(tagline)
        if mo and mo.group(1) is not None:
            if self._transform_funcs:
                return self._apply_transforms(self._key_attrs[0], mo.group(1))
            else:
                return mo.group(1)
        else:
            return b''

    def _make_key_multi(self, tagline):
        attrvals = dict((key, val)
                        for key, val in self._key_re.findall(tagline)
                        if key in self._key_attrs_set)
        for attrname in self._transform_attrs:
            attrvals[attrname] = (
                self._apply_transforms(attrname, attrvals[attrname]))
        return b'\t'.join(attrvals.get(attrname, b'')
                          for attrname in self._key_attrs)

    def _apply_transforms(self, attrname, value):
        # sys.stderr.write('_apply_transforms(' + repr(attrname) + ', '
        #                  + repr(value) + ') -> ')
        value = value.decode('utf-8')
        for transform in self._transform_funcs[attrname]:
            value = transform(value)
        # sys.stderr.write(repr(value) + '\n')
        return value.encode('utf-8')


if __name__ == '__main__':
    VrtSorter().run()
