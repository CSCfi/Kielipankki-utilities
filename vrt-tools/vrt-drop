#! /usr/bin/env python3
# -*- mode: Python; -*-

from itertools import groupby, chain
import enum, os, re, sys, traceback
from operator import itemgetter

from vrtargslib import trans_args, trans_main
from vrtargslib import BadData, BadCode

from vrtnamelib import binxnames, binnamelist, isbinnames, binmakenames
from vrtdatalib import binasrecord

def parsearguments():
    description = '''

    Drop the given fields (positional attributes).

    '''

    parser = trans_args(description = description)

    parser.add_argument('--names', '-n', metavar = 'name(s)',
                        dest = 'names', action = 'append',
                        type = binxnames, default = [],
                        help = 'drop the named fields (comma-separated names)')

    parser.add_argument('--dots', action = 'store_true',
                        help = 'drop all dotted names')

    args = parser.parse_args()
    args.prog = parser.prog

    # print(args.names) ; exit(23)
    return args

class Kind(enum.Enum):
    # kind of line (group of them)
    meta = 1
    data = 2
    begin = 3
    names = 4
    comment = 5

def identify(line):
    # used by groupby to identify the kind of a line group
    if line.startswith(b'<!--'):
        if isbinnames(line): return Kind.names
        else: return Kind.comment
    if line.startswith(b'<sentence'): return Kind.begin
    if line.startswith(b'<'): return Kind.meta
    return Kind.data

def getget(args, source):
    '''From args.names from the command line and field names given in
    data, return a getter of the desired fields. (Always also include
    the pseudo-name '+' if the document is made "flat" and contains
    it, but never in the first position because that field may contain
    bare angles.)

    '''

    index = { name : k for k, name in enumerate(source) }
    droplet = list(chain(*(names.split(b',') for names in args.names)))

    what = [ name for name in droplet if name not in index ]
    if what:
        raise BadData('no such name: ' + what[0].decode('UTF-8'))

    # matter of taste whether duplicate dropping or nothing to drop
    # are worth raisure but a proper first field must remain together
    # with any '+' field for "flat" data

    unique = set(droplet)
    if len(unique) < len(droplet):
        raise BadData('duplicates')

    target = [ name for name in source
               if name not in unique
               if not (args.dots and b'.' in name) ]

    if len(target) == len(source):
        raise BadData('nothing to drop')

    if not target:
        raise BadData('cannot drop all fields')

    if target[0] == b'+':
        if len(target) == 1:
            raise BadData('cannot drop all fields bar +')
        else:
            # include any '+' but not in the first position
            target[0], target[1] = target[1], target[0]

    positions = (index[name] for name in target)
    if len(target) == 1:
        getone = itemgetter(*positions)
        getter = lambda record: (getone(record),)
    else:
        getter = itemgetter(*positions)

    return getter

def makenew(target):
    return binmakenames(*target)

def main(args, inf, ouf):
    status = 1
    try:
        implement_main(inf, ouf, args)
        status = 0
    except BadData as exn:
        print(args.prog + ':', exn, file = sys.stderr)
    except BadCode as exn:
        print(args.prog + ':', exn, file = sys.stderr)
    except BrokenPipeError:
        print(args.prog + ': broken pipe in main', file = sys.stderr)
    except KeyboardInterrupt:
        print(args.prog + ': keyboard interrupt', file = sys.stderr)
    except Exception as exn:
        print(traceback.format_exc(), file = sys.stderr)

    return status

def implement_main(inf, ouf, args):

    seen = False
    def isnotspace(line): return not line.isspace()
    for kind, group in groupby(filter(isnotspace, inf), identify):

        if kind is Kind.data:
            if not seen:
                raise BadData('no names before data')
            for line in group:
                ouf.write(b'\t'.join(get(binasrecord(line))))
                ouf.write(b'\n')
            continue

        if kind is Kind.begin:
            if not seen:
                raise BadData('error: no names before sentence')
            for line in group: ouf.write(line)
            continue

        if kind is Kind.meta:
            for line in group: ouf.write(line)
            continue

        if kind is Kind.data:
            for line in group: ouf.write(line)
            continue

        if kind is Kind.names:
            seen = True
            for line in group:
                names = binnamelist(line)
                get = getget(args, names)
                ouf.write(makenew(get(names)))
            continue

        if kind is Kind.comment:
            for line in group: ouf.write(line)
            continue

        raise BadCode('this cannot happen')

if __name__ == '__main__':
    trans_main(parsearguments(), main,
               in_as_text = False,
               out_as_text = False)
