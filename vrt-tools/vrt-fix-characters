#! /usr/bin/env python3
# -*- mode: Python; -*-

import html
from itertools import groupby, chain
import os, re, sys, traceback

from vrtargslib import trans_args, trans_main
from vrtargslib import BadData, BadCode

from vrtnamelib import xname, isnames, namelist, nameindices
from vrtdatalib import asrecord, escape

def parsearguments():
    description = '''

    Replace invalid characters or character entities in attribute
    values and named fields with something that is valid in VRT and
    hopefully closer to what was intended.

    Input must already be UTF-8, much like VRT, have field names.

    Any annotations that may have been based on invalid input may
    become mysterious when the input fields change. It is also too
    late to introduce line breaks or tabs through entities when the
    data is posing as VRT, so something is substituted for such.

    '''

    parser = trans_args(description = description)

    parser.add_argument('--attribute', '-a',
                        metavar = 'attr-name',
                        dest = 'attributes', type = xname,
                        action = 'append', default = [],
                        help = 'an attribute to edit (default: no attributes)')

    parser.add_argument('--field', '-f',
                        metavar = 'field-name',
                        dest = 'fields', type = xname,
                        action = 'append', default = [],
                        help = 'a field to edit (default: no fields)')

    # should allow only one of --entities and --controls and such
    # (TODO Microsoft code page interpretation of C1 as an option)

    parser.add_argument('--entities',
                        action = 'store_true',
                        help = 'repair character entities')

    parser.add_argument('--controls',
                        action = 'store_true',
                        help = '''replace control characters (C0, DEL, C1)
                        with short names''')

    args = parser.parse_args()
    args.prog = parser.prog
    return args

def main(args, inf, ouf):

    # *all* these exceptions should probably go to trans_main, q.v.

    status = 1
    try:
        implement_main(args, inf, ouf)
        status = 0
    except BadData as exn:
        print(args.prog + ':', exn, file = sys.stderr)
    except BadCode as exn:
        print(args.prog + ':', exn, file = sys.stderr)
    except BrokenPipeError:
        print(args.prog + ': broken pipe in main', file = sys.stderr)
    except KeyboardInterrupt:
        print(args.prog + ': keyboard interrupt', file = sys.stderr)
    except Exception as exn:
        print(traceback.format_exc(), file = sys.stderr)

    return status

def implement_main(args, ins, ous):

    def issome(line): return not line.isspace()
    def ismeta(line): return line.startswith('<')

    anames = set(args.attributes)
    fnames = set(args.fields)

    if not (anames or fnames):
        print('{}: warning: no attributes or fields specified'
              .format(args.prog),
              file = sys.stderr)

    fix = None
    for groupismeta, group in groupby(filter(issome, ins), ismeta):

        if groupismeta:
            for line in group:
                if isnames(line):
                    # find field indices to fix
                    fix = nameindices(namelist(line), *fnames)
                    print(line, end = '', file = ous)
                    continue
                
                if line.startswith(('<!', '</')):
                    print(line, end = '', file = ous)
                    continue

                # line is a start tag and may contain attributes
                print(fixmeta(args, line, anames), end = '', file = ous)
                continue

        # groupisdata aka token lines

        if fix is None:
            raise BadData('no names before tokens')

        for line in group:
            record = asrecord(line)

            for ix in fix:
                # intentionally do not unescape entities yet
                record[ix] = fixdata(args, record[ix])

            print(*record, sep = '\t', file = ous)

def fixmeta(args, start, anames):
    '''Return fixed start-tag line'''
    if not anames: return start
    tag, attrs = parsemeta(start)
    for aname in anames:
        if aname not in attrs: continue
        attrs[aname] = fixattr(args, attrs[aname])
    return composemeta(tag, attrs, end = '\n')

def fixattr(args, value):
    '''Return fixed attribute value'''
    if args.entities: value = re.sub(entitylike, unbreakity_quote, value)
    if args.controls: value = value.translate(CONTROLS)
    # return '[{}]'.format(value) # testing
    return value

def fixdata(args, value):
    '''Return fixed positional-field value'''
    if args.entities: value = re.sub(entitylike, unbreakity, value)
    if args.controls: value = value.translate(CONTROLS)
    # return '[{}]'.format(value) # testing
    return value

def unbreakity(match, quote = False):
    '''Consider any &\w+; an attempted named entity (ASCII only), also
    consider any numerical-looking entity up to and including the
    semicolon, and actually consider any string of such up to and
    including a semicolon - type "&lt&lt&lt;" that complicators of
    legend in their legendary wisdom used to consider a good idea,
    syntactically - and any lone & < > " ' as such - and return a
    canonical, minimal interpretation.

    '''
    ents = match.group()
    if len(ents) == 1:
        # ents is one of & < > " '
        result = (
            ENTITIES.get(ents) or
            (quote and QUOTES.get(ents)) or
            (not quote and ents in ('"', "'") and ents) or
            # this cannot happen
            '[??{}]'.format(repr(ents))
        )
    else:
        # ents looks like an entity sequence: undo and redo
        result = ''.join([
            (
                ENTITIES.get(part) or
                (quote and QUOTES.get(part)) or
                TANKEROES.get(part) or
                # to handle mispeling here
                # though really why bother
                escape(part)
            )
            for mo in re.finditer('&[^&]+', ents)
            for part in [ html.unescape(mo.group()) ]
        ])
    # value = '[{} => {}]'.format(ents, result)
    return result

unbreakity_quote = lambda match : unbreakity(match, quote = True)

entitylike = re.compile(R'''

    # eventual semicolon is mandatory on an entity sequence
    # or the entity sequence will not be recognized as such

    (?: & [a-z] +
      | & \# [0-9] +
      | & \# x [0-9a-f] + ) + ;
    | [&<>"']

''', re.ASCII | re.IGNORECASE | re.VERBOSE)

ENTITIES = {
    # Three characters are entified in both meta and data
    '&amp;' : '&amp;',
    '&lt;' : '&lt;',
    '&gt;' : '&gt;',
    '&' : '&amp;',
    '<' : '&lt;',
    '>' : '&gt;'
}

QUOTES = {
    # Two more characters are entified in meta
    '&quote;' : '&quote;',
    '&apos;' : '&apos;',
    '"' : '&quote;',
    "'" : '&apos;'
}

TANKEROES = {
    # The characters that absolutely must not be allowed
    # because they would formally break lines or fields,
    # and something is trying to smuggle them in through
    # a nentity. Substitute basically anything at all.

    # Many other control characters are merely annoying.

    # U+0009 CHARACTER TABULATION
    # aka HT, HORIZONTAL TAB
    # ==> SYMBOL FOR HORIZONTAL TABULATION
    '\t' : '\u2409',

    # U+000a LINE FEED
    # ==> SYMBOL FOR LINE FEED
    '\n' : '\u240a',

    # U+000b LINE TABULATION
    # aka VT, VERTICAL TAB
    # ==> SYMBOL FOR VERTICAL TABULATION 
    '\v' : '\u240b',

    # U+000b FORM FEED
    # aka FF
    # ==> SYMBOL FOR FORM FEED
    '\0x0c' : '\u240c',

    # U+000d CARRIAGE RETURN
    # aka CR
    # ==> SYMBOL FOR CARRIAGE RETURN
    '\r' : '\u240d',

    # U+001c INFORMATION SEPARATOR FOUR
    # aka FS, FILE SEPARATOR
    '\x1c' : '(FS)',

    # U+001d INFORMATION SEPARATOR THREE
    # aka GS, GROUP SEPARATOR
    '\x1d' : '(GS)',

    # U+001e INFORMATION SEPARATOR TWO
    # aka RS, RECORD SEPARATOR
    '\x1e' : '(RS)',

    # U+0085 NEXT LINE
    # aka NEL
    # ==> SYMBOL FOR NEWLINE (ok?)
    '\x85' : '\u2424',

    # U+2028 LINE SEPARATOR
    '\u2028' : '(LS)',

    # U+2029 PARAGRAPH SEPARATOR
    '\u2029' : '(PS)',
}

CONTROLS = str.maketrans({

    # C0 (ASCII) controls
    '\x00' : '(C0:NUL)',
    '\x01' : '(C0:SOH)',
    '\x02' : '(C0:STX)',
    '\x03' : '(C0:ETX)',
    '\x04' : '(C0:EOT)',
    '\x05' : '(C0:ENQ)',
    '\x06' : '(C0:ACK)',
    '\x07' : '(C0:BEL)',
    '\x08' : '(C0:BS) ',
    '\x09' : '(C0:HT) ', # cannot happen
    '\x0A' : '(C0:LF) ', # cannot happen
    '\x0B' : '(C0:VT) ', # cannot happen
    '\x0C' : '(C0:FF) ', # cannot happen
    '\x0D' : '(C0:CR) ', # cannot happen
    '\x0E' : '(C0:SO) ',
    '\x0F' : '(C0:SI) ',
    '\x10' : '(C0:DLE)',
    '\x11' : '(C0:DC1)',
    '\x12' : '(C0:DC2)',
    '\x13' : '(C0:DC3)',
    '\x14' : '(C0:DC4)',
    '\x15' : '(C0:NAK)',
    '\x16' : '(C0:SYN)',
    '\x17' : '(C0:ETB)',
    '\x18' : '(C0:CAN)',
    '\x19' : '(C0:EM) ',
    '\x1A' : '(C0:SUB)',
    '\x1B' : '(C0:ESC)',
    '\x1C' : '(C0:FS) ', # cannot happen
    '\x1D' : '(C0:GS) ', # cannot happen
    '\x1E' : '(C0:RS) ', # cannot happen
    '\x1F' : '(C0:US) ',

    # DEL
    '\x7F' : '(CC:DEL)',

    # C1 controls
    '\x80' : '(C1:PAD)',
    '\x81' : '(C1:HOP)',
    '\x82' : '(C1:BPH)',
    '\x83' : '(C1:NBH)',
    '\x84' : '(C1:IND)',
    '\x85' : '(C1:NEL)', # cannot happen ...
    '\x86' : '(C1:SSA)',
    '\x87' : '(C1:ESA)',
    '\x88' : '(C1:HTS)',
    '\x89' : '(C1:HTJ)',
    '\x8A' : '(C1:VTS)',
    '\x8B' : '(C1:PLD)',
    '\x8C' : '(C1:PLU)',
    '\x8D' : '(C1:RI)',
    '\x8E' : '(C1:SS2)',
    '\x8F' : '(C1:SS3)',
    '\x90' : '(C1:DCS)',
    '\x91' : '(C1:PU1)',
    '\x92' : '(C1:PU2)',
    '\x93' : '(C1:STS)',
    '\x94' : '(C1:CCH)',
    '\x95' : '(C1:MW)',
    '\x96' : '(C1:SPA)',
    '\x97' : '(C1:EPA)',
    '\x98' : '(C1:SOS)',
    '\x99' : '(C1:SGCI)',
    '\x9A' : '(C1:SCI)',
    '\x9B' : '(C1:CSI)',
    '\x9C' : '(C1:ST)',
    '\x9D' : '(C1:OSC)',
    '\x9E' : '(C1:PM)',
    '\x9F' : '(C1:APC)',
})

def parsemeta(start):
    '''Parse a start tag into the element name and a dictionary of
    attributes.

    '''
    # capture element name and make sure that the rest of the line
    # consists of something that could be key="value" pairs - is it an
    # overkill to enforce that element name consists of letters only?
    name = re.fullmatch(R'<(\w+)(?: [\w\d._\-]+/?="[^"]*")*>\r?\n?',
                        start)

    if name is None:
        raise BadData('no match: {!r}'.format(start))

    # now be safe to capture (key, value) pairs with a lax pattern

    name = name.group(1)
    rest = re.finditer(R'(\S+)="([^"]*)"', start)
    return name, dict(mo.groups() for mo in rest)

def composemeta(name, attrs, end = ''):
    '''Given element name and a dictionary of attributes, properly
    entified and all, construct the start tag line, sorted, spaced,
    double-quoted.

    '''
    return ( '<{name}{attrs}>{end}'
             .format(name = name,
                     attrs = ''.join(( ' {name}="{value}"'
                                       .format(name = name,
                                               value = value) )
                                     for name, value
                                     in sorted(attrs.items())),
                     end = end) )

if __name__ == '__main__':
    trans_main(parsearguments(), main)
